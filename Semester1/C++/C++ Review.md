## 一、C++ 特性

### 1. 名字空间

* 使用一个完整的名字空间的语法为  —— `using namespace 名字空间标识符;`
* 使用名字空间中的某特定项的语法为 —— `using 名字空间标识符::成员;`

### 2. C++ 输入输出

* 使用不带参数的操纵符时（如 `hex`，`endl`），必须包含头文件 `iostream`
* 使用带参数的操纵符时（如 `setfill`， `setw`），必须包含头文件 `iomanip`
* 除了 `setw`，其他操纵符将永久地改变它所应用到的输入或输出流的状态
* `setw` 的影响仅持续到下一个输入或输出流操作
* 十六进制 ：`cout << hex << i;` 
* 八进制 ：`cout << oct << i;` 
* 十进制 ：`cout << dec << i;` 
* 操纵输出域宽 ：`cout << set(4) << i;`
* 定义特定的填充字符 ：`cout << setfill(*);`
* 定义浮点数的精度 ：`cout << setfill(*) << fixed << setprecision(2);` —— 输出两位小数，长度不足 `setw(10)`的部分用 ***** 填充，下面使用是以 `cout << setw(10) << a << endl;`的方式反映出前面所预设的格式
* 加上 `cout << fixed` 之后使用 `setprecision(n)` 表示输出的**小数位数**，否则（不加 `fixed`）表示输出的总的**有效位数**。前者为定点表示，后者为浮点表示
* 左对齐 `cout<< left` ，右对齐 `cout << right`，与 `setw()` 搭配使用
* `showpoint / noshowpoint` ：强行显示小数点（位数不足用 0 补充） / 取消强行显示小数点
* `showpos / noshowpos` ： 正数添加 + 号 / 取消
* `skipws / noskipws` ：输入前跳过空格 / 取消

### 3. 文件处理

* 必须包含头文件 `#include <fstream> `
* `ifstream infile;` —— 定义输入对象
* `ofstream outfile;` —— 定义输出对象

### 4. 若干重要特性

* `const` 和 `#define` 的区别
  * `const` 可以定义类型，更加精确
  * `#define` 是简单的文本替换，除了定义常量，还可以定义一些简单的函数，类似内联函数
  * `#define` 缺乏检测机制
  * `const` 是一个**左结合**的类型修饰符
    * 如 `const` 位于 `*` 左侧，就是用来修饰指针所指向的变量，即指针指向为常量，如 `const int *ptr = &x; ` / `int const *ptr = &x;`，是用来修饰 `int`
    * 如 `const` 位于 `*` 右侧，就是用来修饰指针本身，即指针本身为常量，如 `int *const ptr = &x;` ，是用来修饰指针
* 四种强制类型转换
  * `static_cast` ：强制类型转换
  * `const_cast` ：去掉常数性
  * `dynamic_cast` ：用于继承层次中的类型转换
  * `reinterpret_cast` ：改变指针类型或将指针与整型转换，慎重使用
* string
  * `getline(输入流，字符串变量)` ：用来读入一整行到 `string` 类型的变量之中，第一个参数为 `ifstream` 类型的对象，第二个参数为 `string` 类型的变量
  * `.erase(开始位置, 长度)` ：删除字符串
  * `.insert(插入位置, 待插入字符串)` ：插入字符串
  * `.replace(替代位置, 子串大小, 子串)` ：替代字符串
  * `.swap(字符串)` ：调换字符换
  * `.substr(索引位置, 字串长度)` ：返回子串
  * `.find(字串, 初始查找位置)` ：查找子串的位置，未找到返回 -1

### 5. 函数

* `int main(int argc, char* argv[]) {}` ：`argc` 是传给程序的参数个数，`argv[0] ~ argv[argc - 1]` 分别为参数的地址 

* 内联函数 ：编译时类似宏替换，函数以内联方式展开，使用函数体替换调用处的函数名，但是扩展时考虑语义，只适合简单的函数，不能内联函数本身，不能直接递归
  * 优点 ：避免了函数调用的开销，程序可以更有效地运行
  * 缺点 ：如果函数很大或调用多次，程序的可执行码变得很大
* 函数签名 ：C++ 要求重载的函数具有不同的签名，函数签名包括：函数名、参数的个数、数据类型和顺序。为了保证函数的唯一性，函数必须拥有独一无二的签名。返回值不是函数签名的一部分。

### 6. new 和 delete

* 与 `malloc calloc free` 的不同：
  * `new new[] delete delete[]` 是内建的操作符，而后者属于 `free` 库函数
  * `new` 和 `delete` 是关键字

### 7. 异常处理

* `try` ：检查异常
* `throw` ：抛出异常
* `catch` ：捕获异常



## 二、类

### 1. 类成员函数的定义方法

* 在类声明之中声明，在类声明之外定义
* 在类声明之中声明及定义（inline），即为内联方式

### 2. 头文件

* 通常将类的声明放在 .h 中，而将成员函数的定义放在 .cpp 文件中
* 一般不要将类外定义的成员函数放在 .h 文件中，因为头文件通过 `#include` 被多个不同的文件所包含的话可能出现函数重复定义而出错
* 内联函数在多文件被 include 时，不是重复定义

### 3. 类成员

* 使用关键字 `static` 修饰的类的成员，称之为类成员（静态成员）
* 包括类数据成员和类成员函数
* 这种成员属于类的本身，而不属于类对象，为一个类的所有对象所共享
* 使用方法
  * 对象.静态数据成员或成员函数
  * 对象指针->数据成员或成员函数
  * 类::数据成员或成员函数



## 三、继承

### 1. 改变访问限制

* 使用 `using` 声明可以改变成员在派生类中的访问限制
* 如果基类的某个共有成员函数在继承类中不适合，则可以通过 `using` 声明将其转变为私有成员函数，从而使它在派生类中隐藏起来

### 2. 保护成员

* 派生类可对从基类继承来的保护成员进行访问，也就是说保护成员在派生类中是可见的
* 派生类不能访问一个基类对象的保护成员，也就是派生类实例化之后就不能访问基类的保护成员了

### 3. 派生类构造函数

* <派生类构造函数名>(<总参数列表>) : <基类构造函数名>(<参数列表>)  { <派生类新增数据成员初始化> }
* 如 `Derived(int m, int n, int k): Base(m, n) {}`

### 4. 三种继承

|          | public    | protected | private |
| -------- | --------- | --------- | ------- |
| 共有继承 | public    | protected | 不可见  |
| 私有继承 | private   | private   | 不可见  |
| 保护继承 | protected | protected | 不可见  |



### 4. 子类型化和类型适应

* 只有在公有继承下，派生类是基类的子类型



## 四、多态

### 1. 多态性分为两类：

* 编译时多态性 ：通过函数重载或运行时重载
* 运行时多态性 ：又叫运行期绑定，通过类的继承关系和虚函数来实现

### 2. 运行期绑定和编译期绑定

* 多态就是将**函数名称**动态地绑定到**函数入口地址**的**运行期绑定机制**
* `如果对一个函数的绑定发生在运行时刻而非编译时刻，我们就称该函数是多态的`，否则是属于编译期绑定

### 3. C++ 中，只有满足某些特定条件的成员函数才可能是多态的

* 必须存在一个继承体系结构
* 继承体系结构中的一些类必须具有同名的虚成员函数
* 至少有一个基类类型的指针或基类类型的引用。这个指针或引用可用来对虚成员函数进行调用

### 4. 基类和派生类

* 当声明了基类的一个成员函数为虚函数后，即使该成员函数没有在派生类中被显式地声明为虚函数，但他在所有派生类中也将自动成为虚函数
* 最好将所有的派生类中都将它声明为虚函数，避免特地需要检查基类的不便
* 如果虚函数在类声明之外定义，可以不使用 `virtual` 关键字
* C++ 仅允许将类成员函数定义为虚函数，顶层函数不行

### 5. 实现

* C++ 使用 vtable（虚成员函数表）来实现虚成员函数的运行期绑定
* 使用动态绑定的程序会影响效率，因为虚成员函数表需要额外的空间，而对虚成员函数表的查询也需要额外的时间

### 6. 构造函数和析构函数

* 构造函数不能是虚函数，析构函数可以是虚函数
* 因为建立一个对象，必须拥有完全的信息，需要知道要建立的对象的具体类型，而虚拟调用某个函数可以不知道它的类型
* 如果基类有一个指向动态分配内存的数据成员，并定义了负责释放这块内存的析构函数，就应该将这个析构函数声明为虚成员函数，这样可以保证在以后添加该类的派生类时发挥多态性的作用
* 静态成员函数（类成员函数）不能是虚成员函数

### 7. 重载、覆盖与遮蔽

* 重载：函数名相同，函数签名不同，在编译期绑定；静态多态，发生于同一命名空间
* 覆盖：函数名相同，函数签名也相同，且在运行期绑定；发生在具有继承关系的不同类的成员函数之间
* 遮蔽：函数名相同，函数签名可相同可不相同，且在编译期绑定；发生在具有继承关系的不同类的成员函数之间
  * 一般函数的 hiding：静态多态；
  * 虚函数的 hiding：
    * override：动态多态（同时满足3个条件）
    * 其他：静态多态
* 如果成员函数不是虚函数，那么任何调用均为编译期绑定（遮蔽）
* 要产生多态效果，必须为两个类定义具有相同函数签名的虚函数
* 总结
  * 函数重载发生在同一个类或顶层函数中，同名的函数具有不同的参数列表
  * 函数覆盖发生在继承层次中，该函数在父类中必须是virtual，而子类的该函数必须与父类具有相同的参数列表
  * 函数遮蔽（隐藏）发生在继承层次中，父类和子类同名的函数中，不属于函数覆盖的都属于函数遮蔽

### 8. 抽象基类

* 如果一个类中至少有一个纯虚函数，那么该类被称为抽象类
  * 纯虚函数：在虚成员函数声明的结尾加上 `= 0`，即 `virtual 函数类型 函数名称(参数表) = 0;`
  * 纯虚函数没有函数体，故派生类只有重新定义纯虚函数之后才能调用它
  * 加上 `= 0` 的意思是将指向函数体的指针值赋初值 0
* 抽象基类不能被实例化，而且至少必须有一个纯虚成员函数
* 可以声明抽象类的指针或引用，当用这种基类指针指向其派生类的对象时，必须在派生类中重载纯虚函数
* 只有虚函数才能声明为纯虚成员函数
* 使用：
  * 抽象基类定义公共接口，实现共享
  * 抽象基类通常只有 `public()` 成员函数

### 9. 运行期类型识别

* `dynamic_cast` 仅对多态类型有效
  * 操作正确的前提是转型的源类型必须有虚函数，但与转型的目标类型有无虚函数无关
  * <> 内部的目标类型必须是一个指针或引用
  * 转换之后如果安全，则返回地址，否则返回 `NULL`
* 通常来说，向上转型可以成功，向下转型不能成功，若不存在继承关系，转型也不能成功
* `typeid` 用来确定某个表达式的类型
  * 用法：`typeid(typename)`，可用来判断是不是一个类型
  * `typeid(typename).name()` 可得到类型名



## 五、操作符重载

### 1. 基本操作符重载

* 可以被重载的操作符：
  * `new `
  * `new[]`
  * ` delete ` 
  * `delete[]`
  * ` +` 
  * ` -` 
  * ` *` 
  * ` /` 
  * ` %` 
  * ` ^` 
  * ` &` 
  * ` |` 
  * ` ~` 
  * ` !` 
  * ` =` 
  * ` <` 
  * ` >` 
  * ` +=` 
  * ` <<` 
  * ` >>` 
  * ` <<=` 
  * ` >>=` 
  * `++`
  * ` !=` 
  * ` <=` 
  * ` >=` 
  * ` &&` 
  * ` ||` 
  * ` ++` 
  * ` --` 
  * ` ,` 
  * ` ->*` 
  * ` ->` 
  * ` (` 
  * ` )` 
  * `[]`
* 不能被重载的操作符：
  * `?:`
  * ` .` 
  * ` *` 
  * `::` —— 因为操作符左边是一个类型名，而不是一个表达式
* 通常对于一个二元操作符函数，重载为成员函数时，只能显式声明一个形参，这个形参表示右操作数，左操作数调用该函数
* 重载一个一元操作符，其函数不需要参数

### 2. 顶层函数操作符重载

* 参数表中必须包含一个类对象，否则编译系统不能确定操作符是内建的还是用户定义的
* 顶层函数进行二元操作符重载时， 需要两个参数，分别对应操作符的两个操作数
* 顶层函数进行一元操作符重载时， 需要一个参数，对应操作符的一个操作数
* 下标操作符 `[]`、赋值操作符 `=`、函数调用操作符 `()`、指针操作符 `->` 必须以类成员函数的形式进行重载，这样可以确保第一个操作数是类的对象
* 使用顶层操作符重载的优点：
  * 非对象操作数可以出现在操作符的左边
  * 使用类成员函数时，第一个操作数必须是类的对象

### 3. friend 函数

* 一个类的 friend 函数可以访问该类的私有成员和保护成员，但它不是类的成员函数
*  friend 函数不符合面向对象，存在争议，建议仅在重载操作符时使用
*  friend 函数不仅可以是顶层函数，也可以是另一个类中的成员函数
* 一个函数可以同时被多个类声明为 friend
* friend 的关系是单向的、不可传递的

### 4. 输入与输出操作符的重载 

* `>>` `<<`
* 不能对系统类的源代码进行修改，故将 `>>` 重载函数设计为顶层函数，并可将其设计为要操作的对象的类的友元函数
* 如：`istream& operator>>(istream& in, Complex &c){return in>>c.real>>c.imag;} `

### 5. 赋值操作符的重载

* 重载赋值操作符时， 通常返回调用该操作符的对象的引用，这样赋值就能连续进行
* 一般情况下系统会自动帮忙重载赋值操作符，但是当类中含有动态分配的内存时，会出现类似默认拷贝函数的情况，赋值操作的两个数 指向同一块动态分配的内存，因此需要自定义重载赋值操作符

### 6. 自增与自减操作符重载

* `operator ++();` // 重载前置自增操作符
* `operator ++(int);` // 重载前置后增操作符，并不会用到这个 int 型参数

### 7. 转型操作符重载

* 转型构造函数可以将其他类型转换成所需的类的类型
* 如果要进行相反的转型动作，即要将类的类型转化成其他类型，可对转型操作符进行重载（类型转化成员函数）。
* 语法：`operator othertype(){}`，不包含形参和返回类型

### 8. 内存管理操作符重载

* `void* operator new(size_t size){} `
* `void operator delete(void *p){}`



## 六、模板与标准模板库

### 1.  函数模板

```
template <typename T>
T min(T a[], int n) {
	代码;
}
```

### 2. 类模板

* 类是对问题的抽象，而类模板是对类的抽象，类模板称为带参数的类

* 格式

  ```
  template <模板参数表>
  class <类模板名> {
  	<类成员声明>
  };
  ```

* eg：

  ```
  template <class T>
  class MyTemClass {
  	private:
  		T x;
  	public:
  		void SetX(T a) {x = a;}
  		T GetX() {return x;}
  };
  ```

* 在模板类的外部定义其成员函数：

  ```
  template <class T>  // 不能省略模板声明
  void MyTemClass<T>::SetX(T a) {
      x = a;
  }
  ```

* 模板可以有多个类参数，这些参数用逗号隔开

* 声明模板类的对象 `MyTemClass <int> intObject;`

* 类模板可以用非类参数的参数，称为函数类型参数

* 设计继承：基类和派生类可以是模板类也可以不是模板类


### 3. STL

* STL 容器可分为两组
  * 序列式容器—— vector、list、deque 等
  * 关联式容器—— set、map、multiset、multimap 等
  * 容器适配器是基本容器的衍生物，有三种：stack、queue、priority_queue 
    * stack、queue 默认衍生自 deque
    * priority_queue 默认衍生自 vector