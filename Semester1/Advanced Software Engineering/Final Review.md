#### 注 1：

本文档资料来源于中国科学技术大学《高级软件工程》教学内容。



#### 注 2：题型

* 填空
* 选择 - 单选/不定项
* 辨析
* 简答/问答
* 分析



#### 注 3：

下列内容中标题为单个数字的为老师上课提问的内容（重点内容），其他标题由 `.` 组成的内容为附加内容。





## 一、软件工程（概述）

#### 0. 什么是软件工程？

* 将工程化的思想/方法应用于软件开发的过程之中
* 软件工程 Fritz Bauer ：为了经济的获得可靠的，在实际机器上高效运行的软件，而建立和使用的好的工程原则。 
* 软件工程[IEEE93]：软件工程是
  * (1) 将系统的、规范的、可度量的方法应用于软件的开发、运行和维护的过程。即工程化方法应用于软件。
  * (2) 在(1)中所述方法的研究

#### 0.1   软件工程管理

* 目的：为了按照进度和预算完成软件开发计划 
* 内容：
  * 成本估算 
  * 进度安排 
  * 人员组织 
  * 质量保证

#### 0.2 软件危机

1968年第一次提出了“软件危机”(software crisis)这个名词并第一次提出了软件工程这个概念

软件危机包含两方面问题:

* 如何开发软件，以满足不断增长、日趋复杂的需求
* 如何维护数量不断膨胀的软件产品

#### 0.3 现代软件工程最根本的就是人跟物的关系

是人和机器(工具、自动化)在不同层次的不断循环发展的关系，新的方法技术不断产生。例如:

* 面向对象的分析设计方法
* 软件复用
* 基于组件的软件开发
* 软件过程管理
* 能力成熟度模型的提出等

#### 0.4  计算机世界的软件

* 软件 = 程序 + 数据 + 文档
* 程序 = 算法 + 数据结构

#### 1. SE 和 CS 有什么区别？

* CS ：研究计算机相关的理论
* SE ：把计算机技术看作工具，用以解决问题

#### 2. 怎么认识质量？

* 超越的观点（Transcendental view）: 质量是可以认识而不能定义的
* 用户的观点（User view）: 质量是恰好达到目的
* 制造的观点（Manufacturing view）: 质量是与需求说明的一致
* 产品的观点（Product view）: 质量是与产品的内在特性相联系的
* 基于价值的观点（Value-based view）: 质量取决于顾客愿意支付的金额

#### 2.1 至少从三个方面考虑：

* 产品质量

| 产品运行 | •     正确性    •     可靠性    •     完整性    •     可用性    •     效率性 |
| -------- | ------------------------------------------------------------ |
| 产品修改 | •     可维护性   •     适应性   •     可测试性               |
| 产品变迁 | •     可移植性   •     可复用性   •     互用性               |

* 过程质量

* 商业环境中的质量

#### 3. 影响软件工程实践的七个关键因素（Wasserman 1996年提出）

* 交付时间的重要性
* 计算行业经济的变化趋势
* 功能强大的桌面运算
* 互联网络
* 面向对象的技术
* 图形用户界面
* 瀑布模型的不可预知性

#### 3.1  Wasserman 的软件工程规范8个基本概念

* Abstraction 抽象
* Analysis and design methods and notations 分析、设计方法和符号
* User interface prototyping 用户界面原形
* Software architecture 软件体系结构
* Software process 软件过程
* Reuse 复用
* Measurement 度量
* Tools and integrated environments 工具和集成环境 ：平台集成 数据集成 表示集成 控制集成 过程集成





## 二、软件过程

#### 1. 软件过程（软件生命周期）：是软件生命周期内为达到一定目标而必须实施的一系列相关过程的集合。 

三个时期：软件定义/软件开发/软件运行（维护）

* 可行性研究与计划
* 需求分析
* 概要设计（总体设计）
* 详细设计
* 实现（编码）
* 集成测试
* 确认测试
* 使用和维护

#### 1.1 什么是过程？

过程是指为达到给定目的而执行的一系列活动的有序集

#### 1.2 软件工程层次

* 四层：工具/方法/过程/质量焦点  
* 软件过程将各个技术层次结合在一起，并实施合理地、及时地开发计算机软件

#### 2. 软件生命周期各阶段产品

* 可行性研究 ： 可行性报告
* 需求分析 
  * 软件需求规格说明书 SRS
  * 用户需求定义文档
* 概要设计 
  * 概要设计规格说明书
  * 数据库或数据结构设计说明书
  * 集成测试计划
* 详细设计
  * 详细设计规格说明书
  * 单元测试计划
* 实现 ：源程序代码
* 单元测试 ：单元测试报告
* 集成测试
  * 满足概要设计要求的程序
  * 组装（集成）测试报告
* 确认测试 ：可供用户使用的软件产品（文档，源程序） 

#### 2.1 软件过程各阶段内容

* **可行性研究**：

  任务：了解用户要求和现实环境。从技术、经济、市场等方面研究并论证开发该软件系统的可行性。

  * **技术可行性**：当前的软件开发方法和工具能否支持需求的实现;
  * **操作可行性**：用户能否在特定的环境下使用这个软件;
  * **经济可行性**：开发和使用、维护这个软件的成本能否被用户所接受。

* **需求分析**：

  任务：确定用户对软件系统的需求

  过程：需求分析人员必须与用户不断、反复地交流和商讨，使用户需求逐步准确、一致、完全。

  * **功能需求**：软件必须要完成的功能;
  * **性能需求**：软件的安全性、可靠性、可维护性、精度、错误处理、适应性、用户培训等;
  * **运行环境约束**：待开发的软件产品必须满足的环境要求

* **概要设计**：

  * 任务：根据 SRS 建立目标软件系统的总体结构、设计全局数据库和数据结构，规定设计约束，制定组装测试计划等等。
  * 原则：坚持功能模块内部高内聚，功能模块之间松耦合的；坚持与需求规格说明书的一致性

* **详细设计**：

  * 任务：细化概要设计所生成的各个模块，并详细描述程序模块的内部细节（算法，数据结构等），形成可编程的程序模块，制订单元测试计划

* **实现**：

  * 任务：调试、单元测试、系统集成，验证程序与详细设计文档的一致性
  * 方法：以详细设计规格说明书为依据、基于某种程序设计语言进行编码

* **单元测试**：

  * 任务：对模块进行测试
  * 途径：
    * 黑盒测试
    * 白盒测试

* **集成测试**：

  * 任务：组装测试应满足概要设计的要求。
  * 途径：
    * 测试模块连接的正确性;
    * 测试系统或子系统的 I/O;
    * 测试系统的功能和性能。

* **确认测试**：

  * 任务：根据软件需求规格说明书，测试软件系统是否满足用户的需求
  * 方法：用户参与，以软件需求规格说明书为依据进行确认测试
  * 工具：专用测试工具

* **使用和维护**：

  * 任务：软件工作环境不断变化，软件也必然跟着变化，软件必须不断进化以满足客户的需求变化，这是软件产品最根本的特性。软件维护占用软件开发60%以上的工作量。
  * 正确性维护 / 扩充性维护 / 适应性维护 / 软件产品的新版本

#### 3. 单元测试、集成测试、确认测试 各自的任务

* 单元测试 ：对模块进行测试
* 集成测试 ：应满足概要设计的要求
* 确认测试 ：根据软件需求规格说明书，测试软件系统是否满足用户的需求

#### 4.0 过程模型

* 软件过程模型是软件开发全过程、软件开发活动以及它们之间关系的结构框架
* 过程框架 (process framework)：定义了若干小的框架活动，为完整的软件开发过程建立了基础。
* 软件通用过程框架：可适用于绝大多数的软件项目的过程框架：**沟通-策划-建模-构建-部署**
*  每个任务集合都由工作任务、工作产品、 质量保障点、项目里程碑构成

#### 4. 瀑布模型的优缺点 （1970 W.royce）

* 特点
  * 软件开发过程与软件生命周期是一致的
  * 相邻二阶段之间存在因果关系
  * 需对阶段性产品进行评审

* **优点**
  * **软件生命周期模型，使软件开发过程可以在分析、设计、编码、测试和维护的框架下进行**
  * **软件开发过程具有系统性、可控性，克服了软件开发的随意性**
* **缺点**
  * **项目开始阶段用户很难精确的提出产品需求，由于技术进步，用户对系统深入的理解，修改需求十分普遍。**
  * **项目开发晚期才能得到程序的运行版本，这时修改软件需求和开发中的错误代价很大。**
  * **采用线性模型组织项目开发经常发生开发小组成员“堵塞状态”，特别是项目的开始和结束。**

#### 4.1 V 模型：软件开发过程与测试的对应

#### 4.2 快速原型模型

* 过程：
  * 用户/客户给出软件产品的一般需求
  * 开发小组和用户共同定义软件总体目标，标识已知需求
  * 对界面、功能、人机交互方式等，进行设计并建造原型
  * 强调“快速”，釆用基于构件的软件开发方法，尽量缩短软件开发周期，不宜釆用过多的新技术
  * 用户/客户对原型进行评估修改需求、更新设计、完善原型直至确定需求。

* 优点：
  * 原型模型支持软件需求开发，帮助用户和开发人员理解需求，是软件需求工程的关键。
  * 它产生的正式需求文挡，是软件开发的基础。
  * 如果开发的原型是可运行的，它的若干高质量的程序片段和开发工具可用于工作程序的开发。
  * 原型的开发和评审是系统分析员和用户/客户共同参予的迭代过程，每个迭代循环都是线性过程。

#### 4.3  RAD（快速应用开发）模型：侧重于短暂开发周期，多个团队可并行进行下面的工作

* 业务建模 —> 数据建模 —> 过程建模 —> 应用生成 —> 测试修正
* 缺点：
  * 对于大型软件项目，需要足够的人力资源以建立多个相对独立的 RAD 团队。
  * 如果开发者和客户没有短时间内没有为急速完成整个系统做好准备，RAD 项目将会失败
  * 如果系统难以模块化，建造原型所需构件就有问题
  * 如果高性能是一个指标，原型模型也可能不奏效。
  * 技术风险很高的情况下不宜采用该模型

#### 4.4 螺旋模型 （Boehm，1988）

* **螺旋模型 = 线性模型 + 迭代.原型 + 系统化**
* 螺旋模型适用于计算机软件整个生命周期
* 优点：
  * 符合人们认识现实世界和软件开发的客覌规律
  * 支持软件整个生命周期
  * 保持瀑布模型的系统性、阶段性
  * 利用原型评估降低开发风险
  * 开发者和用户共同参与软件开发，尽早发现软件中的错误
  * 不断推出和完善软件版本，有助于需求变化，获取用户需求，加强对需求的理解

#### 4.5 增量模型

* 增量：小而可用的软件
* 特点：在前面增量的基础上开发后面的增量，每个增量的开发可用瀑布或快速原型模型迭代的思路

#### 4.6 形式化开发方法

* 类似瀑布模型的软件开发方法，其开发过程是用**形式化数学转换**将系统描述转换成一个可执行程序
* 设计、实现和单元测试等开发过程由转换过程替代，在转换的过程中，每个步骤增加细节，直到形式化描述被转换变成一个可执行程序。
* 特点及优缺点：
  * 用严格的、数学的符号体系来规约、开发和验证基于计算机的系统。
  * 解决软件开发过程使用其它范型难以克服的二义性、不完整性和不一致性。
  * 可以产生无缺陷软件的承诺。
  * 费时、昂贵、难沟通，需要培训
  * **是建造重要的、安全的软件的开发者可以考虑开发范型。**

#### 4.7  构件集成模型（专用过程模型）

* 融合了螺旋模型的特征
* 基于构件库
* 支持软件开发的迭代方法
* 软件重用
* 基于构件的开发可以缩短大约70%的开发周期，降低84%的项目成本。
* **统一软件开发过程就是基于构件开发模型的代表。使用统一建模语言。**

#### 5.0 RUP（Rational Unified Process、Rational 统一过程）

* **用例驱动、以体系结构为核心、迭代及增量**
* 由 UML 方法和工具支持
* 目标：在可预见的日程和预算前提下，确保满足最终用户需求的高质量产品
* 适合于大范围项目和机构的方式捕捉了许多现代软件开发过程的最佳实践
* 各阶段里程碑：
  * 先启：生命周期目标里程碑
  * 精化：生命周期体系架构里程碑
  * 构建：初始可运行能力里程碑
  * 产品化：产品发布
* **迭代**：是一个基于确定计划和评估标准并且产生一个可执行发布版（内部的或外部的）的独特活动序列。

#### 5. RUP模型的四个阶段

* 先启 ：定义整个项目的范围
* 精化 ：制定项目计划、描述功能、建立体系架构框架和可执行的“体系结构基线”
* 构建 ：构造软件产品
* 产品化 ：将软件产品移交到最终用户手中

#### 6. RUP 模型和瀑布模型的区别

* RUP 每个阶段都包含软件生命周期的整个过程；瀑布模型每个阶段是独立的
* RUP 通过一次次迭代完成和完善软件开发；瀑布模型的软件开发是一次性的
* RUP 适用于大型复杂软件项目；瀑布模型适用小型简单软件项目

#### 7. 先启阶段主要工作

* 确定项目开发的目标和范围
* 定义主要的需求：用例以及主要的用例场景
* 根据一些主要的用例场景来构建一个基本架构
* 估算开发周期和成本估计潜在的风险
* 主要实践活动 —— 用例建模

#### 7.1 精化阶段主要工作

* 精化阶段不是一个需求或设计阶段，而是一个迭代实现核心架构并降低高风险的阶段
* 在细化前不需要定义大多数需求，10% 的详细用例书写出来即可
* 先处理具有风险的元素，开始实际产品代码的编写，产生可执行架构
* 除了极少数理解良好的问题外需要多次迭代

#### 8. 构建阶段主要工作

* 尽快完成软件产品的开发
* 迭代实现遗留下来的风险较低和比较容易的元素，准备部署
* 在保证开发进度的同时达到足够的软件质量
* 获得一些有用的版本（alpha，beta 等）

#### 8.1 转化阶段

* 获得涉众的认同：产品部署已经完成并且满足预定的质量标准
* 尽快达到最终稳定的产品基线

#### 8.2 统一过程的模型

* 用例模型：用例与用户之间关系（交互时）
* 分析模型：系统的行为初步分配给一组对象
* 设计模型：系统静态结构定义为子系统、类、接口，并定义由子系统、类和接口之间的协作所实现的用例
* 实现模型：构件（表现为源代码）和类到构件的映射
* 实施模型：计算机的物理节点和构件到这些节点的映射
* 测试模型：用于验证的测试用例

#### 8.3 过程建模工具和技术

* Choose Language or Notation：选择语言或符号
* Static model：显示了输入转化为输出的过程
* Dynamic model：能够执行过程，用户可以看到中间过程和最后结果是如何转化的



## 三、 软件计划与管理

#### 0.0 项目计划与管理概述

* 目的：为了使软件项目能够在预定成本􏰀、进度、质量的前提下顺利完成，必须对软件工程项目进行计划、组织、监控和管理
* 项目的特征：唯一性 / 一次性 / 整体性 / 多目标性 / 寿命周期阶段性
* 管理是所有人类组织都有的一种活动，这种活动由五要素组成：**计划、组织、指挥、协调、控制**，管理就是实施这五要素
* 项目管理：所谓项目管理，就是项目的管理者，在有限的**资源约束**下，运用**系统的观点、方法和理论**，对项目涉及的全部工作进行有效地管理
* 软件项目管理：
  * 是为了使软件项目能够按照预定的成􏰀本、进度、质量顺利完成，而对成本􏰀、人员、进度、 质量、风险等进行分析和管理的活动。
  * 对象：软件工程项目，它所涉及的范围覆盖了整个软件工程过程。
  * 目的：
    * 让软件项目尤其是大型项目的整个软件生命周期（从分析、设计、编码到测试、维护全过程）都能在管理者的控制之下，以预定成本􏰀按期、按质的完成软件交付用户使用。
    * 从已有的成功或失败的案例中总结出能够指导今后开发的通用原则、方法，同时避免前人的失误。
  * 范围：**人员 / 产品 / 过程 / 项目**

#### 1.0 项目（过程）跟踪

* (Activity) 活动：项目的一部分，发生在一段时间内
* (Milestone) 里程碑：一个活动的完成，某一特定时刻
* (Precursor) 前驱：在活动开始之前必须发生的一个或一组事件
* (Duration) 持续时间：完成一个活动需要的时间长度
* (Due date) 截止日期：活动必须完成的日期

#### 1. 拿到项目先做什么？ 进行项目分解

#### 1.1 项目分解

* 含义：项目组在项目实施期间要完成的工作或要开展的活动的一种层次性、树状的项目活动描述。组织并定义了整个项目范围，建立和确认项目范围，以便达成共识。工作元素经常被收集在 WBS 词典中，一般包括工作描述和其他项目信息
* **目的：明确项目所包含的各项工作；项目分解的结果就是 WBS**
* 意义：WBS 图是实施项目、创造最终产品或服务所必须进行的全部活动的一张清单，也是进度计划、人员分配、预算计划的基础
* 内容：项目分解就是先把复杂的项目逐步分解成一层一层的要素（工作），直到具体明确为止

#### 2. WBS 是什么？

Work Breakdown Structure 任务分解结构

#### 3. 简述 WBS 的叶子结点

* WBS 主要是将一个项目分解成易于管理的几个部分或几个细目，以便确保找出完成项目工作范围所需的**所有工作要素**，它是一种在项目全范围内分解和定义各层次工作包的方法
* **WBS 结构层次越往下层则项目组成部分的定义越详细，WBS 最后构成一份层次清晰、可以具体作为组织项目实施的工作依据**

* **WBS 通常是一种面向“成果”的“树”，其最底层（叶子结点）是细化后的“可交付成果”，该树组织确定了项目的整个范围。但 WBS 的形式并不限于“树”状，还有多种形式。**

#### 3.1 WBS 的用途？

* 确定工作范围
* 配备人员
* 编制资源计划
* 监视进程
* 明确阶段里程碑
* 内容的验证

#### 4.1 WBS 分解注意事项？ 

* WBS 分解的规模和数量因项目而异
* 收集与项目相关的所有信息
* 参看一下类似的项目的 WBS，与相关人员讨论
* 可以参照相关模板
* **最低层是可控的和可管理的，但是避免不必要的过细，最好不要超过 7 层**
* **软件项目推荐分解到 40 小时的任务**
* **工作包（处于最底层）必须有一个提交物**
* 定义任务完成的标准
* 必须有利于责任分配
* 可以准备 WBS 的字典
* 进行评审

#### 5. WBS 的两种分解方法

* **基于可交付成果的划分**
  * 上层一般以可交付成果为导向
  * 下层一般为可交付成果的工作内容
* **基于工作过程的划分**
  * 上层按照工作的流程分解
  * 下层按照工作的内容划分

#### 5.1 WBS 表现形式

* 图形显示
* 锯齿列表

#### 5.2 WBS 字典

由于项目，特别是对于那些较大的项目来说都有许多工作块，而对于这些最底层的工作块，要对它们有全面、详细和明确的文字说明。因此，常常把这些所有的工作块文字说明汇集在一起，编成一个项目的工作分解结构词典 (WBS dictionary)，以便需要时查阅。

#### 5.4 WBS 应用

* WBS：工作分解结构
* OBS：组织分解结构 （人员）
* CBS：成􏰀本分解结构 
* RBS：风险分解结构
* WBS — OBS：责任矩阵
* WBS — CBS：帐户(科目) 矩阵
* WBS — RBS：风险矩阵

#### 6.1 项目人员（五类）

* 项目管理人员
* 高级管理人员
* 开发人员
* 客户
* 最终用户

#### 6. 如何选择人员？（以下特性可能影响个人工作的生产力）

* 开展工作的能力
* 工作兴趣
* 经验
  * 类似应用
  * 类似工具或语言
  * 类似技术
  * 类似开发环境
* 培训
* 与其他人交流的能力
* 共同承担责任的能力
* 管理技能

#### 6.1 项目组织

* 如何选择适当的结构？
  * 小组人员的背景和工作方式 
  * 小组的工作数目
  * 顾客和开发人员的管理方式

*  三种常见的程序设计小组的组织形式

  * 核心程序员制小组（高结构化） 
  * 民主制小组（松散结构） 
  * 层次式小组（高结构化和松散结构两者之间）

* 组织结构的比较

  | 高度结构化 |  松散的结构  |
  | :--------: | :----------: |
  |  高确定性  |    不确定    |
  |    重复    | 新技术或工艺 |
  |   大项目   |    小项目    |

#### 7.0 规模（工作量）估算

* 估算的步骤
  * 在技术允许的条件下，应从最详细的工作分解结构开始 
  * 精确定义度量的标准
  * 估计底层每一模块的规模，汇总已得到总体的估算
  * 适当考虑偶然因素的影响
* LOC 估算与 FP 估算
  * LOC：代码行可以分为无注释的源代码行 (NCLOC) 和注释的源代码行 (CLOC)，源代码的总行数 LOC 即为 NCLOC 与 CLOC 之和。利用 LOC 为指标进行估算。
    * 代码行数：LOC 或 KLOC
    * **生产率：Pl = L / E**，其中 L 是软件项目代码行数，E 是软件项目工作量(人月 PM)，Pl是软件项目生产率 (LOC / PM)
    * **代码出错率：EQRl = Ne / L**，其中 Ne 是软件项目的代码错误数，EQRl 是每千行代码的错误数
    * **每行代码平均成本：Cl = S / L**，其中 S 是软件项目总开销(元/美元)，Cl 是软件项目每行代码的平均成􏰀本
    * **文档与代码比：Dl = Pd / L**，其中Pd是软件项目文档页数，Dl是每千行代码的平均文档数
  * FP：功能点，根据事务信息处理程序的基􏰀本功能定义的，利用 FP 为指标进行估算。
    * 功能点分析法是可在需求分析阶段基于系统功能的一种规模估算方法，它的运用可以贯穿于整个软件生命周期。是基于应用软件的外部、内部特性以及软件性能的一种间接的规模测量。
    * 功能点分析的一个主要的目标就是从**用户的角度**定义系统的能力

#### 7. LOC、FP 的优缺点

* LOC 
  * 优点：用软件代码行数估算软件规模简单易行
  * LOC 缺点： 
    * 代码行数的估算依赖于程序设计语言的功能和表达能力
    * 采用代码行估算方法会对设计精巧的软件项目产生不利的影响
    * 在软件项目开发前或开发初期估算它的代码行数十分困难
    * 代码行估算只适用于过程式程序设计语言，对非过程式的程序设计语言不太适用
* FP
  *  优点：
    * 与程序设计语言无关，它不仅适用于过程式语言，也适用于非过程式的语言;
    * 软件项目开发初期就能基本上确定系统的输入、输出等参数，功能点度量能用于软件项目的开发初期。
  * FP 缺点：
    * 它涉及到的主观因素比较多，如各种权函数的取值
    * 信息领域中的某些数据有时不容易采集
    * FP 的值没有直观的物理意义。

#### 7.1 比较

* 代码行度量依赖于程序设计语言，而功能点度量不依赖于程序设计语言；
* FP 法需要某种“人的技巧”，因为计算是基于主观的而非客观的数据；
* 两者可以结合使用。例如：在实践应用中，在全生命周期采用 FP 的同时，在项目内部局部结合使用 LOC 作为补充手段。

#### 8. 功能点分类 

* 数据类型 ：ILF（内部逻辑文件）、EIF（外部接口文件）
* 人机交互类型 ：EI（外部输入）、EO（外部输出）、EQ（外部查询）：都是逻辑处理
  * EI：外部输入是指一个基本处理，它处理的是来自本应用边界之外的一组数据或者控制信息。外部输入的基本目的是为了维护一个内部逻辑文件（ILF）或者改变系统行为。
  * EO：外部输出是指一个向应用边界之外发送数据或者控制信息的基本处理。
  * EQ：外部查询是指一个向应用边界之外发送数据或者控制信息的基本处理。

#### 9. EO 和 EQ 的区别

* EO：基本目的是为了向用户展示一组经过了除了提取之外的其他逻辑处理的数据或者控制信息。其他处理包括至少一个数学演算或者对衍生数据的生成。可能包括对 ILF 的维护或者对系统行为的改变。
* EQ：基本目的是为了向用户展示提取的数据或者控制信息。逻辑处理里不包含数学公式或者计算以及对衍生数据的生成。不维护 ILF，也不会引起系统行为的改变

#### 10.0 文件

* ILF 内部逻辑文件
  * 指一组以用户角度识别的，在应用程序边界内且被维护的逻辑相关数据或控制信息。
  * ILF 主要的目的是通过应用程序的一个或多个基本处理过程来维护数据。
* EIF 外部接口文件
  * 指一组在应用程序边界内被查询，但它是在其他应用程序中被维护的，以用户角度来识别的，逻辑上相关的数据。
  * 一个应用程序中的 EIF 必然是其他应用程序中的 ILF。
  * 主要目的是为边界内的应用程序提供一个或多个通过基础操作过程来引用的一组数据或信息。
* ILF 和 EIF 的复杂性取决于 DET 和 RET 的数量

* FTR（应用文件类型）：
  * 一个由交易功能所维护的 ILF
  * 一个被交易功能所读取的 EIF

#### 10. DET（Data element type） 和 RET（Record element type）的概念

* DET 是一个以用户角度识别的，非重复的有业务逻辑意义的**字段**
* RET 是指一个 EIF / ILF 中用户可以识别的 **DET 的集合**。
* 如果把 DET 简单理解为字段的话，那么 RET 就可以简单理解为数据库中的表

#### 11. 功能点计算的大致过程

![image](https://github.com/SeanCST/USTC/blob/master/Semester1/images/FP.png)

#### 11.1 FP 计算：FP = CT * [0.65 + 0.01 * ∑Fi ]

* CT 为􏰁未调整的功能点  
* Fi 是复杂性调节值，Fi 取值 0,1,...,5，当 Fi = 0 时，表示 Fi 不起作用， Fi = 5 时，表示 Fi 作用最大

#### 11.2 FP 相关计算

*  生产率：Pf = FP / E，Pf 表示每人月完成的功能点数，E 是软件项目工作量(人月 PM)
*  平均成􏰀本：Ci = S / FP，Ci 表示每功能点的平均成本
*  文档与功能点比：Di = Pd / FP，Di 表示每个功能点平均具有的文档页数
*  代码出错率：EORi = Ne / FP，EORi 表示每个功能点的平均错误个数

#### 11.3 成本估算

* 估算类型
  * 专家判定
  * 算法模型
  * 机器学习

#### 11.4 可靠性估计 ：与软件可靠性密切相关的程序中残留错误数的估算和平均故障间隔时间的估算

* 错误植入法：假设程序中测试前残留的错误数为 N，然后人为地在程序中植入 Ns 个错误，这些植入的错误对测试人员来说是未􏰁知的。经过一段时间的测试，如果发现的错误数为 n，其中植入的错误数为 ns，则原程序中残留的错误估算值 N' 可用下式计算：N′ = (n * Ns) / ns
* 分别测试法：
  * Er = 程序中原有的残留错误数
  * E1 = 第一组测试员发现的错误数 
  * E2 = 第二组测试员发现的错误数 
  * E0 = 两组测试员同时发现的错误
  * 则程序中残留错误的估计值可用下列计算：Er = (E1 * E2) / E0
* 软件平均故障间隔时间估算
  * 统计程序运行 H 小时期间出现的故障次数 r 来估算软件故障率 λ
  * 估算公式如下：λ = r / H
  * 软件的平均故障时间 MTTF 可用下式估算：MTTF = 1 / λ = H /r 
  * 根据软件项目组对以往项目的故障修复时间的统计，可得到平均故障修复时间 MTTR，则软件平均故障间隔时间可用下式估算：MTBF = MTTF + MTTR = H / r + MTTR

#### 11.4 进度估算与管理

* 目标：确保软件项目在规定的时间内按期完成
* 项目进度管理任务
  * 定义所有的项目任务以及它们之间的依赖关系
  * 制订项目的进度安排
  * 规划每个任务所需的工作量和持续时间
  * 在项目开发过程中不断跟踪项目的执行情况，发现那些􏰁未按计划进度完成的任务对整个项目工期的影响，并及时进行调整
* 进度管理指导原则：
  * 划分
  * 相互依赖性
  * 时间分配
  * 工作量确认
  * 定义责任
  * 定义结果
  * 定义里程碑
* 进度管理过程：
  * 活动定义
  * 活动排序
  * 活动历时估计
  * 制定进度计划
  * 进度控制
* 进度安排图表
  * 网络图：展示项目中的各个活动以及活动之间的逻辑关系； 网络图是活动排序的一个输出；网络图可以表达活动的经历时间。常用网络图有 PDM、ADM。
    * PDM (Precedence diagram)
      * 构成 PDM 网络图的基􏰀本特点是节点
      * 节点表示活动
      * 用箭线表示各活动之间的逻辑关系
      * 可以方便的表示活动之间的各种逻辑关系
      * 每项活动有唯一的活动号，每项活动都注明了预计工期
      * PDM 包括四种依存关系或先后关系：完成对开始 / 完成对完成 / 开始对开始 / 开始对完成
  * 甘特图
    * 也称时间表（Timeline chart），用来建立项目进度表
    * 在甘特图中，每项任务的**完成以必须交付的文档和通过评审为标准**
    * 因此在甘特图中，文档编制与评审是软件开发进度的里程碑
  * 里程碑图
    * 里程碑显示项目进展中的重大工作完成 
    * 里程碑不同于活动
      * 活动是需要消耗资源的
      * 里程碑仅仅表示事件的标记

#### 12.0 编制进度计划

* 编制项目进度计划
  * 确定项目的所有活动及其开始和结束时间
  * 是监控项目实施的基础，它是项目管理的基准
  * 计划是三维的，考虑时间、费用和资源 
* 编制项目进度计划步骤
  * 进度编制 
  * 资源调整 
  * 成􏰀本预算 
  * 计划优化调整 
  * 形成基线计划

#### 12. 制定进度计划的常见技术是？

* 关键路径 （CPM）：根据指定的网络顺序逻辑关系和单一的历时估算，计算每个活动的单一的、确定的最早和最迟开始和完成日期，计算网络图中完成时间最长的路径和浮动时间。
  * 正推法：按照时间顺序计算最早开始时间和最早完成时间的方法
    * 首先建立项目的开始时间
    * 项目的开始时间是网络图中第一个活动的最早开始时间
    * 从左到右，从上到下进行任务编排
    * 当一个任务有多个前置时，选择其中最大的最早完成日期作为其后置任务的最早开始日期
    * ES（最早开始时间）、EF（最早完成时间）、LS（最晚开始时间）、LF（最晚结束时间）
  * 逆推法：按照逆时间顺序计算最晚开始时间和最晚结束时间的方法
    * 首先建立项目的结束时间
    * 项目的结束时间是网络图中最后一个活动的最晚结束时间
    * 从右到左，从下到上进行计算
    * 当一个前置任务有多个后置任务时，选择其中最小最晚开始日期作为其前置任务的最晚完成日期
* 计划评审技术（PERT）：
  * 利用经加权平均的所需时间估算，计算各项活动所需时间。PERT 同 CPM 的主要差别在于 PERT 使用**期望值来估算时间**，而不使用 CPM 所用的最大可能估计。
  *  PERT 的计算特点：在 PERT 中，假设各项工作的持续时间服从 β 分布，近似地用三时估计法估算出三个时间值，即最短、最长和最可能持续时间，再加权平均算出一个期望值作为工作的持续时间
  * 为了进行时间的偏差分析（即分布的离散程度），可用方差估算
* 图形评审技术（GERT）：
  * 可对网络逻辑和活动所需**时间估算进行概率处理**（即，某些活动可能根􏰀本不进行，某些活动可能只部分进行，而其它活动则可能多次进行)。
* 具体技术的选择考虑如下因素：
  * 项目的规模大小
  * 项目的复杂程度
  * 项目的紧急性
  * 对项目细节掌握的程度
  * 总进度是否由一、两项关键事项所决定
  * 有无相应的技术力量和设备

#### 13. 什么是风险？

在给定情况下和特定时间内，那些可能发生的结果与预期结果之间的差异，差异越大，风险越大

#### 14. 什么是风险后果、概率、控制？

* 风险后果 ：与该事件有关的损失
* 风险概率 ：事件发生的可能性
* 风险控制 ：我们能改变结果的程度

#### 15. 什么是风险成本？

***风险成本 = 风险概率 × 风险后果***

#### 16. 风险管理的四个方面

风险管理 ：识别评估风险，建立、选择、管理和解决风险的可选方案和组织方法

* **风险标识** ：潜在的风险列表
  * 风险的类别：
    * 项目风险
    * 技术风险
    * 商业风险
  * 影响软件风险的因素：
    * 性能风险
    * 成本风险
    * 支持风险
    * 进度风险
* **风险预测** ：评价每种风险发生的可能性或概率以及当该风险发生时所导致的后果 
  * 建立一个尺度，以反映风险发生的可能性
  * 描述风险的后果
  * 估算风险对项目及产品的影响
  * 标注风险预测的整体精确度以免产生误解
  * 建立风险表：
    * 第 1 列列出所有的风险
    * 第 2 至 4 列列出每个风险的种类（项目风险、技术风险、商业风险等）、发生的概率以及所产生的影响
    * 综合考虑风险发生的概率和风险所产生的影响，对风险表排序
* **风险评估** ：进一步审查风险预测阶段对各种风险预测的精确度，并对每个风险因素定义一个风险参考水准。当性能下降、成本超支、支持困难或进度延迟超过相应的水准时会导致项目被迫终止。（风险计划和应急计划）

  * 风险评估活动通常采用下列形式的三元组： [ri, li, xi]
  * ri ：风险

  * li ：风险发生的概率
  * xi ：风险产生的影响
* **风险管理与监控** ：建立处理风险的策略
  * 风险避免：对付风险的最好办法是主动地避免风险，即在风险发生前，分析引起风险的原因，然后采取措施，以避免风险的发生
  * 风险监控：监控可以提供风险指示（是否正在变高或变低）的因素
  * 风险管理及监控计划 RMMP：对于每个风险，特别对那些高概率高影响的风险应制定 RMMP，RMMP 的实施会导致额外的项目开销

#### 17.0 软件质量管理

* 高质量的软件应该具备以下条件：
  * 满足软件需求定义的功能和性能
  * 文档符合事先确定的软件开发标准
  * 软件的特点和属性遵循软件工程的目标和原则
* 还应该考虑在预算和进度范围内交付，因此在项目进行过程中要对偏差进行控制

#### 17. QC（质量控制） 具体是什么？包含什么？

* 为保证每一件工作产品都满足需求而应用于整个开发周期中的一系列**审查、评审和测试**
  * 质量控制在创建工作产品的过程中**包含**一个**反馈循环**，通过对质量的反馈，使得能够在得到的工作产品不能满足其规约时调整开发过程 
  * 所有工作产品都应该具有定义好的和**可度量的规约**，这样就可以将每个过程的产品与这一规约进行比较 

* 方法 ：
  * 采用技术手段保证软件质量
  * 组织技术评审
  * 加强软件测试
  * 推行软件工程标准
  * 对软件的修改、变更进行严格控制
  * 对软件质量进行度量

#### 18. QA（质量保证）具体是什么？

* 建立一套有计划、有系统的方法，来向管理层保证拟定出的标准、步骤、实践和方法能够正确地被所有项目所采用。**（管理者的眼睛）**

* 目的：**使软件过程对于管理人员来说是可见的**。它通过对软件产品和活动进行评审和审计来验证软件是合乎标准的。软件质量保证组在项目开始时就一起参与建立计划、标准和过程。这些将使软件项目满足机构方针的要求。

* 目标：
  * 软件质量保证工作是有计划进行的
  * 客观地验证软件项目产品和工作是否遵循恰当的标准、步骤和需求 
  * 将软件质量保证工作及结果通知给相关组别和个人
  * 高级管理层接触到在项目内部不能解决的问题

#### 18.1 软件质量评价特性

* 常见的 6 个方面：
  * 正确性
  * 可靠性
  * 易用性
  * 效率
  * 可维护性
  * 可移植性
* 其他方面的特性：
  * 健壮性
  * 完整性（安全性）
  * 可测试性
  * 可再用性
  * 可互连性

#### 18.2 软件评审

* 软件评审是软件质量保证的重要手段
* 通常在软件工程过程的每个活动（如需求分析、设计、编码）的后期进行正式的软件评审
* 两种主要评审活动：项目管理评审和技术评审
  * 项目管理评审的任务是针对适用的项目计划、进度安排、标准和指南进行项目状态的评价
  * 技术评审的任务是举行技术评审以评价正在考虑中的软件产品或服务，并提供下列证据：
    * 它们是完整的
    * 它们符合标准和规范
    * 对它们的更改是正确地实施的，并且仅仅影响配置管理过程所标明的区域
    * 它们遵循适用的规程
    * 它们已为下一个活动做好准备
    * 根据项目的计划、进度安排、标准和指南正在进行开发、动作或维护
* 软件评审的方法：正式评审 / 非正式评审

#### 19. 什么是软件配置？

由在软件工程过程中产生的所有**信息项**构成的，它可以看作该软件的具体形态（软件配置项）在某一时刻的**瞬间影像**

#### 20. 什么是软件配置管理？为什么要进行配置管理？

协调软件开发**使得混乱减到最小的技术**叫做软件配置管理，它是一种标识、组织和控制修改的技术，目的是使错误达到最小并最有效地提高生产效率。贯穿整个软件生命周期与软件工程过程。

#### 20.1 软件配置管理

* 目标：标识变更 • 控制变更 • 确保变更 • 报告变更
* 基本概念：
  * 软件配置项 (Software Configuration item，SCI) ：为配置管理设计的软件的集合，它在配置管理过程中作为单个实体对待。配置项主要有两大类：
    * 属于产品组成部分的工作成果，例如源代码、需求文档、设计文档、测试用例等等
    * 在管理过程中产生的文档例如各种计划、监控报告等等，这些文档虽然不是产品的组成部分，但是值得保存。
  * 软件配置 (Software configuration) ：软件产品在不同时期的组合。该组合随开发工作的进展而不断变化。
  * 配置管理 (Configuration management) ：应用技术的和管理的指导和监控方法以标识和说明配置项的功能和物理特征，控制这些特征的变更，记录和报告变更处理和实现状态并验证与规定的需求的遵循性。
  * 版本􏰀 (Version) : 与计算机软件配置项的完全编篡或重编篡相关的计算机软件配置项的初始发布或再发布
  * 发布 (Release) : 一项配置管理行为，它说明某配置项的一个特定版􏰀已准备好用于特定的目的（例如发布测试产品)
  * 基线 (baseline) ：已经过正式审核与同意，可用作下一步开发的基础，并且只有通过正式的修改管理过程方能加以修改的规格说明或产品。
  * 变更控制 (change control) ：是指提议作一项变更并对其进行估计、同意或拒绝、调度和跟踪的过程。
  * 配置状态记录 (configuration status accounting) ：一种配置管理的元素，它为有效地管理某一配置所需的信息组成。此信息包括列出经批准的配置标识表、建议变更的配置状态和经批准变更的实现状态。

#### 21. 什么是配置审计？

配置审计（Configuration audit）是指对所要求的全部配置项均已产生出来，**当前的配置与规定的需求相符所作的证明**。技术文件说明书完全而准确地描述了各个配置项目，并且曾经提出的所有变更请求均已得到解决的过程。

#### 21.1 配置项管理的关键活动

* 配置项识别：所有配置项都应按照相关规定统一编号，按照相应的模板生成，在引入软件配置管理工具进行管理后，这些配置项都应以一定的目录结构保存在配置库中。
* 配置空间管理：在引入了软件配置管理工具之后，所有开发人员都会被要求把工作成果存放到由软件配置管理工具所管理的配置库中去。所以要对工作进行空间配置。
* 版本控制：对系统不同版􏰀本进行标识和跟踪的过程，演化图：描述对象的变更历史
* 变更控制：变更控制结合人的规程和自动化工具以提供一个管理变更的机制
* 配置审计
  * 审计：通过调查研究确定已制定的过程、指令、规格说明、基线及其他特殊要求是否恰当和被遵守、以及实现是否有效
  * 通过正式技术评审或软件配置审计来保证变更的有效性
* 配置状态报告 (CSR) 主要内容：
  * 配置库结构和相关说明;
  * 开发起始基线的构成;
  * 当前基线位置及状态;
  * 各基线配置项集成分支的情况; 
  * 各私有开发分支类型的分布情况; 
  * 关键元素的版本􏰀演进记录;
  * 其它应予报告的事项。





## 四、敏捷软件开发

#### 1. 敏捷的出发点

* 以人为本
* 尽快的交付客户满意的增量

#### 2. 敏捷的四条宣言

* **个体和交互** 胜过 过程和工具
* **可以工作的软件** 胜过 面面俱到的文档
* **客户合作** 胜过 合同谈判
* **响应变化** 胜过 遵循计划
* *虽然右项也有价值，但我们认为左项具有更大的价值*

#### 2.1 敏捷实践原则

* 我们最优先要做的是通过**尽早的、持续的交付有价值的软件**来使客户满意。 
* 即使到了开发的后期，也**欢迎改变需求**。敏捷过程利用变化来为客户创造竞争优势。
* 经常性的交付**可以工作的软件**，交付的间隔可以从几个星期到几个月，交付的时间间隔越短越好。
* 在整个项目开发期间，业务人员和开发人员必须**天天都在一起工作**。
* 围绕**被激励起来的个体**来构建项目。给他们􏰀提供所需的环境和支持，并且信任他们能够完成工作。
* 在团队内部，最具有效果并且富有效率的传递信息的方法，就是**面对面的交谈**。
* **工作的软件**是首要的进度度量标准。 
* 敏捷过程􏰀提倡**可持续的开发进度**。责任人、开发者和用户应保持一个长期恒定的开发速度。
* 不断关注**优秀的技能和好的设计**会增强敏捷能力。 
* 简单 — 使**未完成的工作**最大化的艺术 — 是根本的。 
* 最好的构架、需求和设计出自于**自组织的团队**。
* 每隔一定时间，团队会在如何才能更有效的工作方面进行反省，然后相应地对自己的行为进行调整。

#### 3. XP 模型和 Scrum 模型的异同点

* **Scrum 和 XP team 都在迭代的方式下工作，但 Scrum 的周期一般是从两周到一个月  /  XP 的周期是一或两周。**
* Scrum team 在一个 sprint 中是不接受任何任务变更的。一旦 sprint planning meeting 提交了任务，直到 sprint 结束，都不会接受任何改变 **/** 而 XP 的团队在一个迭代中，如果新的 feature 跟原来的 feature 规模和大小差不太多，在原来的 feature 还没有开始进行的前提下，可以用新的 feature 更换原来的 feature。
* XP 团队会严格按照任务的优先级来工作。所有的任务都被客户划分了优先级，团队都被要求在该优先级下工作。相比之下，Scrum 团队中的 PO 也会划分 backlog 中的优先级，但 scrum 团队的人员会自己决定他们以何种顺序来完成所有的任务。当然，通常来说，还没见过哪个 scrum 团队不选择优先做优先级最高的条目。当然有时候，scrum 团队也会选择先做优先级稍微低一些的条目，比如有些任务并非在 sprint 刚一开始就实施的，尽管它的优先级很高。或者适合做某项任务的人，正在做其他的工作，这个时候，优先级也会得到调整。
* **Scrum 并没有定义任何工程实践的方法，它只是提供了一个实践的框架给你。但XP（极限编程）却会给你这样的一些东西。比如测试驱动开发， 自动化测试，结对编程，简单设计，重构等等。**
* **scrumMaster 负责监督整个 Scrum 进程**
* XP：素材划分为任务，迭代进行到一半时应完成本次迭代中所安排的半数素材，每次迭代结束时会给客户演示当前可运行的程序，客户以新的用户素材的方式提供反馈 **/** Scrum： 任务为backlog ，sprint backlog 是一个 sprint 周期内需要完成的任务

#### 3.1 XP 极限编程实践

* 完整团队
* 计划游戏
  * 通过一次次迭代和发布，项目进入了一种可以预测的、舒适的开发节奏。
  * 开发人员看到的是他们自己估算、自己度量的开发速度控制的合理计划。选择舒适的任务并保持高的工作质量。
  * 管理人员从每次迭代中获取数据，使用这些数据来控制和管理项目。
* 客户测试
* 简单设计
* 结对编程
* 测试驱动开发
  * 程序中的每一项功能都有测试来验证它的**操作的正确性**。
  * 迫使我们使用不同的**观察点**，可以设计出便于调用的软件。
  * 迫使我们**解除软件中的耦合**。
  * 测试可以作为一种无价的文档形式，这份文档是可编译、可运行的。它保持最新，不会撒谎。
* 改进设计
* 持续集成
* 集体代码所有权
* 系统隐喻
* 可持续的速度
* 编码标准

#### 3.2 Scrum 的一些基本概念

* backlog：可预知的所有任务
* sprint：一次迭代开发的时间周期
* sprint backlog
* scrumMaster：监督进程、修订计划
* time-box：一个用于开会的时间段
* sprint planning time：在启动每个 sprint 前召开
* Daily scrum meeting
* Sprint review meeting
* Sprint Retrospective meeting



## 五、需求工程

#### 1.0 需求工程概述

* 需求：需求是系统的特征，或为了实现目标系统能做什么的一个描述。
* 需求工程：理解客户需要什么，分析要求，评估可行性，协商合理的方案，无歧义地详细说明方案，确认规格说明，管理需求以至将这些需求转化为可运行的系统
* 主要工作产品：需求工程的目的在于为各方提供关于问题的一个书面理解
  * 需求定义文档 (客户角度)
  * 需求规格说明 SRS (技术人员角度) ： 软件设计、实现、测试、维护的基础。
  * 配置管理文档 (支持两个文档间直接对应)

#### 1. 需求工程的出发点

* 获取用户最真实的需求
* 用规格化的语言进行描述

#### 2. 需求分析的四个阶段

* **导出需求** 
  * **需求启动**：确定利益共同者、识别多种观点、协同合作、首次会议、初步“产品要求”文档
  * **需求协同收集**
    * **准备列表：对象列表、服务列表、约束列表、性能列表**
    * 召开评审会议
    * 初步需求说明文档（Mini-specification）
      * 可行性描述
      * 系统或产品的界限说明
      * 参与需求导出的共同利益者列表 
      * 技术环境说明
      * 需求列表以及需求适用的领域限制 
      * 使用场景
      * 原型（可选）
* **分析建模**
* **规格说明**
* **需求确认和校验**

#### 3. 为什么要进行需求分析建模？
* 建立分析模型。从不同的角度、不同的抽象级别精确地说明对问题的理解、对目标软件的需求。
* 模型可帮助用户和分析人员发现、排除用户需求不一致，不合理的部分，挖掘潜在的用户需求。 
* 模型是分析人员根据初步导出的需求而创建的软件系统结构，包括相关的信息流、处理功能、用户界面、行为及设计约束。
* 模型是形成需求规格说明、进行软件设计的基础。

#### 3.1 分析模型

* 目的：提供必要的信息、功能和行为域的说明。模型应能动态的改造，以便于软件工程师更多地了解将要实现的系统，以便于共同利益者更多的了解他们到底需要什么。分析模型是任意给定时刻的需求的快照。
* 分析建模阶段工作产品：以各类建模符号和表现方法提供的一个或多个系统元素的视图（分析模型）

#### 3.2 需求说明文档

* 规格说明是需求分析人员的最终工作产品
* 使用者：后续的设计、开发、测试人员
* 内容与格式：不同开发团队所采用的软件需求规格说明文档的格式和内容并不一致

#### 3.3 需求定义文档

* 包括用顾客的术语描述的需求的记录。这个文档描述了用户和顾客想要看到的东西
* 使用者：用户和顾客

#### 4. 什么是需求校验与需求确认？主要工作是什么？

- **需求确认** ：目的是用来检查获得的**需求定义**是否准确的反应了用户的实际需求。
- **需求校验** ：目的是用来检查**需求规格说明文档**和需求定义文档是否一致。

#### 4.1 需求类型：

* 功能性需求
* 非功能性需求
* 需求的类型：
  * Physicalenvironment 物理环境
  * Interfaces 界面（接口）
  * Users and human factors 用户与人的因素
  * Functionality 功能性
  * Documentation 文档
  * Data 数据
  * Resources 资源
  * Security 安全性
  * Qualityassurance 质量保证

#### 4.2 原型化需求：目的是为了帮我们理解需求并确定最后的设计

* 抛弃式原型法：验证和澄清系统的需求描述，重新构造系统
* 进化式原型法：逐步改进和细化原型，将原型进化为最终系统；增加和修改是演化式原型开发的两个基本特征。






## 六、结构化分析过程

#### 1. 过程论观点——过程论是怎么看待程序世界的？

*  数据和逻辑是**分离的、独立**的，各自形成程序世界的一个方面。所谓世界的演变，是**在逻辑作用**下，数据做改变的一个过程。 
*  过程有明确的开始、结束、输入、输出，每个**步骤有着严格的因果关系**。 
*  过程是相对**稳定的、明确的和预定义**的，小过程组合成大过程，大过程还可以组合成更大的过程。 
*  **结论 ：程序世界本质是过程，数据作为过程处理对象，逻辑作为过程的形式定义，世界就是各个过程不断进行的总体。** 

#### 1.1  两种思想的比较

* 过程论和对象论是两种看世界的观点，没有好坏之分。
* 过程论和对象论不是绝对对立，而是一种辩证统一的对立，两者相互渗透、在一定情况下可以相互转化。如果将对象论中的所有交互提取出来而撇开对象，就变成了过程论，而如果对过程论中的数据和逻辑分类封装并建立交互关系，就变成了对象论。
* 过程论相对确定，有利于明晰演进的方向，但当事物过于庞大繁杂，将很难理清思路。因为过程繁多、过程中又有子过程，容易将整个世界看成一个纷繁交错的过程网，让人无法看清。
* 对象论相对不确定，但是因为以对象为基本元素，即使很庞大的事物，也可以很好地分离关注，在研究一个对象的交互时，只需要关系与其相关的少数几个对象，不用总是关注整个流程和世界。但是，对象论也有困难。例如，如何划分对象才合理？对于同一个驱动力，为什么不同情况下参与对象和交互流程不一样？如何确定？其实，这些困难也正是面向对象技术中的困难。

#### 2. 什么是结构化分析方法？

* 结构化分析方法是一种**建模技术** 
* 基于计算机的系统是**数据流和一系列的转换**构成的 
* 在模型的**核心是数据词典**，它描述了所有的在目标系统中使用的和生成的数据对象。围绕着这个核心的有三种图：ERD、DFD、STD 

#### 3. 结构化分析模型包含什么？

* 数据建模和对象描述

* 功能建模和数据流图 

* 基本加工逻辑说明

* 行为建模

* 数据词典

  ![image](https://github.com/SeanCST/USTC/blob/master/Semester1/images/结构化分析模型.png)


#### 3.1 基本思想

抽象与自顶向下的逐层分解（控制复杂性的两个基本手段）

#### 3.2 结构化分析模型

- 数据字典是模型的核心，包含软件使用和产生所有数据的描述。 
- DFD 数据流图：用于**功能建模**，描述系统的输入数据流如何经过一系列的加工变换逐步变换成系统的输出数据流。 
- ERD 实体关系图：用于**数据建模**，描述数据字典中数据之间的关系。 
- STD 状态迁移图：用于**行为建模**，描述系统接收哪些外部事件，以及在外部事件的作用下的状态迁移情况。 
- 数据对象描述：表示实体 - 关系图中每个数据对象的属性
- 加工规格说明 PSPEC：描述数据流图的每个功能
- 控制规格说明 CSPEC：描述软件控制的附加信息

#### 3.3 数据建模 

* 数据对象、属性与关系 
* **实体 — 关系图 ERD**：描述系统所有数据对象的组成和属性，描述数据对象之间关系的图形语言。一对一 / 一对多 / 多对多

#### 3.4 功能建模

* 用抽象模型的概念，按照软件内部数据传递、变换的关系，自顶向下逐层分解，直到找到满足功能要求的所有可实现的软件为止。
* **数据流图 DFD**
  * 基于计算机的信息处理系统由数据流和一系列的加工构成，这些加工将输入数据流加工为输出数据流
  * 数据流图描述数据流和加工
  * 为了表达数据处理过程的数据加工情况，需要采用**层次结构**的数据流图。按照系统的层次结构进行**逐步分解**，并以分层的数据流图反映这种结构关系，能清楚地表达和容易理解整个系统
* 数据字典
  * 数据字典由**数据条目**组成，数据字典描述、组织和管理数据流图的**数据流、加工、数据源及外部实体**。
  * 数据流图与数据字典是密不可分的，两者结合起来构成软件的逻辑模型
  * 数据字典由字典条目组成，每个条目描述 DFD 中的一个元素
  * 数据字典条目包括：数据流、文件、数据项（组成数据流和文件的数据）、加工、源或宿

#### 3.5  行为建模

* 状态变迁图通过描述状态以及导致系统改变状态的事件来表示系统的行为
* 每个状态代表系统的一种行为模式
* **状态变迁图 STD**

#### 3.6 控制流建模（数据流图的扩充）

* 实时嵌入式系统存在事件驱动机制，通过系统的加工产生控制信息。
* 系统对事件信息的加工必须在指定的时间内完成。
* 实时嵌入式系统的描述不仅需要数据流图，而且还需要控制流图 CFD。





## 七、面向对象分析

####  1. 对象论观点是什么？

- 数据和逻辑不是分离的，而是相互依存的
- 相关的数据和逻辑形成个体，这些个体叫做对象，世界就是由一个个对象组成的。
- 对象具有相对独立性， 对外提供一定的服务。 
- 所谓世界的演进，是在某个“初始作用力”作用下，对象间相互调用而完成的交互，在没有初始作用力下，对象保持静止。 
- 交互并不是完全预定义的，不一定有严格的因果关系，对象间交互是偶然的，对象间联系是暂时的。
- **结论：世界就是由各色对象组成，然后在初始作用力下，对象间的交互完成了世界的演进。**

#### 2. 什么是抽象？

从具体事物抽出，概括出它们共同的方面、本质属性与关系等，而将个别的、非本质的方面、属性与关系舍弃，这种思维过程，称为抽象。

#### 3. 对象层次树？

* **抽象是有层次的**
* 世界并不是一层对象一层类那么简单，对象抽象出类，在类的基础上可以再进行抽象，抽象出更高层次的类。所以经过抽象的对象论世界，形成了一个**树状结构**。
* 这是一棵单根树，最顶层“本体”为唯一的根，最下层叶子节点为基本对象。一切中间节点都为类。
* 越往上的类抽象层次越高，具体度越低，其内涵越小，外延越大；越往下的类抽象层次越低，具体度越高，其内涵越大，外延越小
  * 内涵：指类对属于自己的对象的说明力度
  * 外延：指类能包含的具体对象的总和。
* 抽象层次树不是从根部向下长的，而是从叶子节点向上归纳生成的。
* 某一个叶子节点所代表的对象可以归入所有其祖先结点所代表的类
* 直接问两个叶子节点属不属于一个类没有意义，而要指定抽象层次才有意义。

#### 4. 先有对象还是先有类？

从哲学角度说，先有对象，然后才有类，类和对象是“**一般和特殊**”这一哲学原理在程序世界中的具体体现。

#### 5. 什么是多态？（结合层次树来说）

* 多态性 (polymorphism) 是指同一个操作作用于不同的对象上可以有不同的解释，并产生不同的执行结果。
* 如果一个节点 CNode 非叶子节点也非根节点，如果强行将它看成其任何一个祖先节点 ANode， 并当做 ANode 使用，那么在哲学意义上，叫做多态性

#### 6. 为什么会有耦合？

* 普遍联系：世界上各种对象形成了一张复杂的耦合网，正因为有耦合的存在，世界才能演进。正如马克思主义哲学所说：联系是普遍的、客观的。所以，耦合的存在，有其深刻的哲学意义。
* 什么是耦合？可以看成联系，耦合的存在是世界演进的途径，如果没有耦合，世界就变成了“死世界”，无法演进和发展。所以，世界需要耦合 。我们在开发设计中要降低耦合，但并不是要取消耦合。

![image](https://github.com/SeanCST/USTC/blob/master/Semester1/images/耦合泛化.png)

其中汽车和交通工具属于**泛化耦合**，轮子和方向盘**组合**于汽车，汽车**聚合**成车队，而汽车和司机具有**依赖**关系。

#### 7.0 OO 的具体概念

* 面向对象 = 对象 (object) + 类 (classification) + 继承 (inheritance) + 通信 (communication with messages)
* 面向对象方法成为主流开发方法。可以从下列几个方面来分析其原因：
  * 从认知学的角度来看，面向对象方法符合人们对客观世界的认识规律。
  * 面向对象方法开发的软件系统易于维护，其体系结构易于理解、扩充和修改。
  * 面向对象方法中的继承机制有力支持软件的复用。
* 对象 = 属性 + 操作
* 封装 (encapsulation) 是一种信息隐蔽技术，用户只能看见对象封装界面上的信息，对象的内部实现对用户是隐蔽的。封装的目的是使对象的使用者和生产者分离，使对象的定义和实现分开。
* 类具体表现为一组具有相同属性和相同操作的对象的集合。
* 继承表明了两个类在抽象层次树上的关系。在设计和实现中，通过继承可以实现不同类共享数据和操作。可以实现代码的重用。
* 抽象类 (abstract class)：没有实例的类，它把一些类组织起来，提供一些公共的行为，但并不需要使用这个类的实例，而仅使用其子类的实例。
* 如果一个子类只有唯一一个父类，这个继承称为单一继承。如果一个子类有一个以上的父类，这种继承称为多重继承。
* 动态绑定：在一般与特殊关系中，子类是父类的一个特例，所以父类对象可以出现的地方，也允许其子类对象出现。因此在运行过程中， 当一个对象发送消息请求服务时，要**根据接收对象的具体情况将请求的操作与实现的方法进行连接**，即动态绑定。
* 永久对象是指生存期可以超越程序的执行时间而长期存在的对象

#### 7.0 面向对象分析

* 面向对象分析，就是抽取和整理用户需求并建立问题域精确模型的过程。

#### 7. OO分析时，分析模型做哪些事？

* 需求描述
  * 内容包括：问题范围，功能需求，性能需求，应用环境及假设条件等。需求的描述可以通过前面介绍的需求导出阶段获得。
  * 如何描述需求：图型化方法 / 格式化文档
* 静态模型（对象模型）
* 动态模型（交互次序）
* 功能模型（数据交换）

#### 8. 静态模型包括？

- 找出类 - 对象并进行筛选
- 找出对象之间的关联
- 划分主题 
- 找出对象的属性
- 用继承组织和简化对象类
- 迭代并反复提炼模型

#### 9. 动态模型

* 动态模型是与**时间和变化有关的系统性质**。该模型描述了系统的控制结构，它表示了瞬时的、行为化的系统控制性质；它关心的是系统的控制，操作的执行顺序；它从对象的事件和状态的角度出发，表现了对象的相互行为。
* 如何建立动态模型？
  * 编写脚本
  * 设计用户界面
  * 画事件跟踪图
  * 画状态图
  * 审查动态模型

#### 9.1 功能建模

* 为什么要功能建模？ 功能模型表明了系统中数据之间的依赖关系，以及有关的数据处理功能，它由一组数据流图组成。
* 通常在建立了对象模型和动态模型之后再建立功能模型。根据从功能模型中获得的信息，重新审查静态模型和动态模型，以便进一步完善面向对象分析的结果。
* 功能模型说明对象模型中操作的含义、动态模型中动作的意义以及对象模型中约束的意义。
* 功能模型由多个数据流图组成。与结构化分析中的 DFD 相似。

#### 9.2  两种方法在几方面的比较

|                      |                          结构化软件                          |                         面向对象软件                         |
| :------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   从**概念**方面看   | 结构化软件是**功能**的集合，通过模块以及模块和模块之间的分层调用关系实现 | 面向对象软件是**事物**的集合，通过对象以及对象和对象之间的通讯联系实现 |
|   从**构成**方面看   |            结构化软件 = 过程 + 数据，以过程为中心            |    面向对象软件 = （数据 + 相应操作）的封装，以对象为中心    |
| 从**运行控制**方面看 |          结构化软件采用顺序处理方式，由过程驱动控制          |     面向对象软件采用交互式、并行处理方式，由消息驱动控制     |
|   从**开发**方面看   | 结构化方法的工作重点是设计，因为：在结构化方法中，分析阶段和设计阶段采用了不相吻合的表达方式，需要把在分析阶段采用的具有网络特征的数据流图进行转换 |                 面向对象方法的工作重点是分析                 |
|   从**应用**方面看   | 结构化方法更加适合数据类型比较简单的数值计算和数据统计管理软件的开发 | 面向对象方法更加适合大型复杂的人机交互式软件和数据统计管理软件的开发 |



## 八、统一建模语言 UML

#### 1.0 UML 

* **UML 建模语言，不是一种方法**，它独立于过程，利用它建模时，可遵循任何类型的建模过程
* 为什么叫 UML？
  * U：对多种经典的 OO 方法进行了统一，形成了规范
  * M：用于建立软件开发过程中的各种工程模型
  * L：是一种可视化的（图式）语言
    * 具有指定的建模元素（图式符号）
    * 具有严格的语法（构图规则）
    * 具有明确的语义（逻辑含义）
* 主要构成：
  * **视图 Views**：一个系统应从不同的角度进行描述，从一个角度观察到的系统成为一个视图。视图由多个图构成，它并不是一个图表 (Graph)，而是在某一个抽象层上，对系统的抽象表示。
    * 用户模型视图（用例视图 Use Case View）
      * 作用：描述系统的功能需求，找出用例和执行者
      * 适用对象：客户、分析者、设计者、开发者和测试者
      * 描述使用的图：用例图、交互图、活动图、状态图
      * 重要性：系统的中心，它决定了其他视图的开发，用于确认和最终验证系统
    * 结构模型视图（设计视图/逻辑视图 Logical View）
      * 作用：描述如何实现系统内部的功能
      * 适用对象：分析者、设计者、开发者
      * 描述使用的图：类图和对象图、顺序图、协作图和活动图
      * 重要性：描述了系统的静态结构和因发送消息而出现的动态协作关系
    * 行为模型视图（进程视图 Process View）
      * 作用：描述系统的并发性，并处理这些线程间的通信和同步。展示与系统处理性能相关的主要元素，包括可伸缩性、吞吐量、基本时间性能（考虑分布式系统）
      * 适用对象：开发者和系统集成者
      * 描述使用的图：状态图、顺序图、合作图、活动图、构件图和配置图
      * 重要性：将系统分割为并发执行的控制线程及处理这些线程的通信和同步
    * 实现模型视图（实现视图 Implementation View）
      * 作用：描述系统代码构建组织和实现模块，及它们之间的依赖关系
      * 适用对象：设计者、开发者和测试者
      * 描述使用的图：构件图
      * 重要性：描述系统如何划分软件构件，如何进行编程
    * 环境模型视图（实施视图 Deployment View）
      * 作用：描述系统的物理设备配置，如计算机、硬件设备以及它们之间的相互连接
      * 适用对象：开发者和系统集成者和测试者
      * 描述使用的图：配置图
      * 重要性：描述硬件设备的连接和哪个设备或对象驻留在哪台计算机上执行
  * 图 Diagrams
  * 模型元素 Model elements：代表面向对象中的类，对象，关系和消息等概念，是构成图的最基本的常用的元素
  * 通用机制 general mechanism

#### 1. UML 包含哪九张实际的图？

* 静态图
  * **类图**
    * 展示了系统中类的静态结构，即类与类之间的相互联系。
    * UML 类图包含三种久经考验的类类型：实体类（Entity）、控制类（Control）、边界类（Boundary）
  * **对象图**：对象图是类图的实例，它展示了系统执行在某一时间点上的一个可能的快照。对象图使用与类图相同的符号，只是在对象名下面加上下划线
  * **用例图**
    * 展示各类外部执行者与系统所提供的用例之间的连接，一个用例是系统所提供的一个功能的描述
    * 由参与者、用例、系统边界、箭头组成
  * **构件图**
    * 构件图从软件架构的角度来描述一个系统的主要功能，使用构件图能清楚地看出系统的结构和功能。
    * 构件（组件）：是系统中遵从一组接口且提供其实现的物理的、可替换的部分。构件能够完成独立功能，他是软件系统的组成部分。
    * 类与构件的关系？
  * **配置图（实施图、配置图）**：用来描述系统硬件的物理拓扑结构以及在此结构上执行的软构件。
* 动态图
  * **顺序图**（序列图）
    * 展示了几个对象之间的**动态交互关系**。主要是用来显示对象之间**发送消息的顺序**，还显示了对象之间的交互，即系统执行的某一特定点所发生的事。
    * 重点不是消息本身，而是消息产生的顺序。
    * 一些主要元素：Object、Lifeline、activation（激活期）、message
  * **协作图**
    * 清晰地展示了对象间的关系，协作图没有将时间作为一个单独的维度，因此消息顺序必须通过顺序号来指明。
    * 包含一组对象和链，用于描述系统的行为是如何由系统的成分协作实现的。
    * 协作图上的各对象的协作关系和顺序图上的消息传递是一一对应的。
  * **状态图**
    * 通常是对类描述的补充，它说明该类的对象所有可能的状态以及哪些事件将导致状态的改变。
    * 状态由**状态名、状态变量和活动**三部分表示
  * **活动图**
    * 展示了连续的活动流，通常用来描述完成一个操作所需要的活动。
    * 是结构化开发中流程图和数据流图（DFD）的面向对象等同体。
    * 实心圆表示活动图的起点，带边框的实心圆表示终点；圆角矩形表示执行的过程或活动；箭头表示活动之间的转换，各种活动之间的流动次序；粗线条表示可能会并行进行的过程的开始和结束。
    * 泳道图是活动图的变形，可以在图中指出哪个参与者或类对活动矩形描述的活动负责。

#### 1.1 包图

* 由包和它们间的关系组成的结构图
* 对大型系统进行建模时，把那些**语义相近并且倾向于一起变化的元素组织起来加入同一包**，这样方便理解和处理整个模型。也便于轻松地控制这些元素的可见性。
* 设计良好的包是高内聚、低耦合的。
* 一个包图可以是任何一种 UML 图组成的，通常是用例图和类图

#### 2. 用例图有几种关系？具体是？

* **包含关系**：用例可以简单地包含其他用例具有的行为，并把它所包含的用例行为作为自身行为的一部分，这被称作包含关系。侧重表示被包含用例对执行者提供服务的间接性。
* **扩展关系**：扩展关系是从扩展用例到基本用例的关系，它说明为扩展用例定义的行为如何插入到为基本用例定义的行为中。侧重表示扩展用例的触发不定性。
* **泛化关系**：用例可以被特别列举为一个或多个子用例，这被称做用例泛化。侧重表示了用例间的互斥性。

![image](https://github.com/SeanCST/USTC/blob/master/Semester1/images/包含关系.png)

![image](https://github.com/SeanCST/USTC/blob/master/Semester1/images/扩展关系.png)

![image](https://github.com/SeanCST/USTC/blob/master/Semester1/images/泛化关系.png)

#### 3. 程序员关注哪些图？

程序员关注的是系统的配置、装配等问题，因此会侧重于实现视图。

#### 4. 类与类之间的关系是什么？强弱关系是？

* **关联关系**：连接模型元素及连接实例，用一条实线来表示。对于两个相对独立的系统，当一个系统的实例与另一个系统的一些特定实例存在固定的对应关系时，这两个系统之间为关联关系。
* **依赖关系**：表示一个元素以某种方式依赖于另一个元素，用一条虚线加箭头来表示；对于两个相对独立的系统，当一个系统依赖于另一个系统的服务时，这两个系统间主要体现为依赖关系。
* **聚合关系**：表示整体与部分的关系，用一条实线加虚心菱形来表示。当系统 A 被加入到系统 B 中，成为系统 B 的组成部分，系统 B 和系统 A 之间为聚合关系。
* **组合关系**：表示整体与部分的关系，用一条实线加实心菱形来表示。整体由部分组成，部分需要整体才能实现。
* 上述四种关系的亲密程度：**依赖 < 关联 < 聚合 < 组合**
* **泛化（继承）**：表示一般与特殊的关系，用一条实线加空心箭头来表示

![image](https://github.com/SeanCST/USTC/blob/master/Semester1/images/类之间的关系.png)







## 九、设计工程

#### 1.0 什么是设计？什么是设计模型？

* 设计：将问题转化成解决方案的创造性的活动
* 设计模型：对解决方案的的􏰀描述

#### 1. 概念设计和技术设计指的是什么？（两种不同的观察视角）

* 概念设计：告诉顾客系统将要做什么
* 技术设计：告诉程序员系统将要做什么

#### 1.1 概念设计

* 回答（概念设计要回答的问题）：
  * Where will the data come from 数据来自何地？
  * What will happen to the data in the system 系统中的数据会发生什么情况?
  * What will the system look like to users 系统对用户来说看起来象什么？
  * What choices will be offered to users 能向用户提􏰃供什么选择?
  * What is the timing of events 事件的时间安排如何？
  * What will the reports and screens look like 报告和屏幕看起来像什么？
* 好的概念设计的特征：
  * in customer language with no technical jargon 用顾客语言而不是技术术语
  * describes system functions 描􏰀述系统的功能 􏰂 
  * independent of implementation 独立于实现 􏰂 
  * linked to requirements 与需求相关
* 需要确定：􏰁 
  * 软件系统的结构
  * 各模块功能及模块间联系（接口）
* 过程：
  * 设想可能的方案
  * 选取合理的方案
  * 推荐最佳方案
  * 功能分解
  * 设计软件结构
  * 数据库设计
  * 制定测试计划
  * 编写文档
  * 审查与复审

#### 1.2 技术设计

* 包括（包括对以下条目的􏰀描述）：
  * major hardware components and their function 主要硬件组件和功能
  * hierarchy and function of software components 软件组件的层次和功能 􏰂 
  * data structures 数据结构
  * data flow 数据流
* 主要任务：
  * 编写技术设计说明书：
    * 确定每个模块的**算法**，用工具表达算法的过程，写出模块的详细过程性􏰀描述。
    * 确定每一模块的**数据结构**。
    * 确定**模块接口细节**。
  * 技术（详细）设计是编码的先导。

#### 1.3 五种创建设计的方法

* Modular decomposition 模块分解：将功能分配给组件
* Data-oriented decomposition 面向数据的分解：基于外部数据结构
* Event-oriented decomposition 面向事件的分解：基于系统必须处理的事件和事件改变系统的状态
* Outside-in design 由外而内的设计：基于系统的用户输入（属黑盒方法） 
* Object-oriented design OO设计：确定对象的类和它们之间的相互关系

#### 1.4 三种设计层次

* Architecture 体系结构：系统性能与系统组件关联起来
* Code design 代码设计：为每个组件详细说明算法和数据结构
* Executable design 执行设计：设计的最低级，包括内存分配、数据格式和位组合

#### 1.5 软件体系结构的风格

* 三个方面：
  * 组件（模块）
  * 连接器（组件之间的联系）
  * 组件（模块）组合的限制条件
* 管道与过滤器
  *  􏰁性质
    * 关系表示明确
    * 复用、修改、模拟容易 􏰂 
    * 允许并发执行过滤器
  * 局限性
    * 更适合批处理（不适合交互式处理）
    * 数据流之间需要对应
    * 类似过滤器潜在地重复操作执行
* 隐含调用（事件驱动）
  * 某个组件宣告事件，其他组件处理事件。利用注册程序处理事件
  * 优点：易于复用其他系统组件、对用户界面尤其有用
  * 􏰁缺点：不能确定某个事件的响应、测试系统很难
*  Layering 分层
  * 各层分等级，每层为它的外层􏰃供服务
  * 优点：表示不同的抽象层次、对层的修改通常只影响相邻的两层
  * 缺点：需求阶段定义多层抽象很困难、性能问题
* 解释器
  * 解释器读入字符串并将它们转换成可以执行的实际代码
  * 一般用来构建虚拟机

#### 1.5 重要的设计问题

* 模块性与抽象层次 􏰁 
* 协作设计
* 设计用户界面 
* 􏰁并发
* 设计模式与复用

#### 2.0 优秀设计的特征

* 组件独立性
  * 组件独立是模块化、抽象、信息隐蔽和局部化的直接结果
  * 含义：一个模块具有独立功能而且和其它模块之间没有过多的相互作用
  * 意义：独立的模块容易开发（规模小，接口简单）
  * 独立的模块容易测试和维护；有效阻断错误传播
  * 度量标准：**内聚和耦合**
* 例外设计与处理
* 防错和容错

#### 2. 耦合性

* 定义：指块间联系，即程序结构中不同模块之间互连程度
* 耦合强弱取决于：
  * 模块间接口的复杂程度
  * 调用模块的方式
* 种类：
  * 内容耦合：一个模块可以直接操作另一个模块的数据（如 go to 语句的使用）
  * 公共耦合：全局结构类型的数据
  * 控制耦合：模块间传递的是诸如标记量的控制信息（如 flag）
  * 标记耦合：参数传递的是诸如结构类型的数据【**至少要做到标记耦合**】
  * 数据耦合：参数传递的是一般类型的数据
  * 非直接耦合：通过上级模块进行联系，无直接关联

#### 3. 内聚性

* 块内联系或模块强度，指模块内各个成分（元素）彼此结合的紧密程度，即模块内部的聚合能力。

* “理想的模块仅仅做一件事”

* 种类：

  * 功能性内聚：一个功能一个模块，块内各成分属于一个整体
  * 顺序内聚：模块内各个组成部分都是与一个功能密切相关，并是顺序执行的。一般是一个成份的输出就是下一个成份的输入【**至少要做到顺序内聚**】
  * 通讯内聚：模块内的各个成份都使用同一输入数据，或产生同一输出数据，即借公用数据而联系在一起
  * 过程内聚：块内成份必须按照特定次序执行
  * 时间内聚：因执行时间一样或顺序排列而把几个任务安排一个模块，如把“变量赋初值”、“打开文件”等完成各种初始化任务安排在一个模块
  * 逻辑内聚：块内任务间在逻辑上相似或相同，例如求某班的平均分和最高分，因其输入和输出相同而安排在一个模块内完成。
  * 偶然（巧合）内聚：一个模块所完成的几个任务之间关系松散，互不相关。主要是为了避免重复书写而把重复的代码集成到一个模块内。

  ![image](https://github.com/SeanCST/USTC/blob/master/Semester1/images/内聚.jpeg)

#### 4. 解释一下标记耦合和数据耦合？

* 标记耦合：参数传递的是诸如**结构类型的数据**
* 数据耦合：参数传递的是**一般类型的数据**

#### 5. 怎样降低耦合？

* 降低模块间接口的复杂度
* 改变调用模块的方式

#### 5.1  启发式规则的应用

* 提高模块独立性
  * 模块独立性是划分模块的最高准则
  * 高内聚，尽量一个模块一个功能
  * 低耦合，避免“病态连接”
  * 降低接口的复杂程度
  * 综合考虑模块可分解性、模块可组装性、 模块可理解性、模块连续性和模块保护（因修改错误而引起的副作用被控制在模块的内部）等
* 设计规模适中的模块
* 深度、宽度、扇入、扇出适中 􏰁 
  * 深度：软件结构中控制的层数。一般而言它与系统的复杂度和系统大小直接对应
  * 宽度：软件结构中同一个层次上的模块总数的最大数
  * 扇出：一个模块直接控制（调用）的模块数目。扇出过大说明模块过分复杂；过小也不好，不利于系统平衡分解，3 到 9 为宜
  * 扇入：一个模块的扇入是指直接控制该模块的模块数目。扇入越大说明共享该模块的上级模块越多。整个系统结构呈现“椭圆外型”
* 模块的作用域应该在控制域之内 􏰁 
* 降低模块间接口复杂性
  * 尽量少使用 go to 语句，避免病态连接和内容耦合。
  * 注意全局变量的使用，控制外部耦合和公共耦合的使用。
  * 将数据结构的传递改成数据传递，则标记耦合→数据耦合。
* 设计单入口和单出口的模块
* 设计功能可以预测的模块

#### 6. 作用域和控制域指的是？

* 控制域：控制范围，是包括模块本身以及所有下属模块（直接调用模块和间接调用模块）的集合。
* 作用域：作用范围，它是一个与条件判定相联系的概念。是受该模块内一个判定影响的所有模块的集合。

#### 7. 怎么解决作用域不在控制域之内？

* 模块的作用域应该在控制域之内
* 若不在，有两种改进方法：判定上移和在作用域但不在控制域的模块下移。

#### 8. 扇入扇出适中，系统呈椭圆形

#### 8.1 例外识别和处理

* 典型的例外
  * 无法􏰃提供某种服务
  * 提􏰃供了错误的服务或数据 􏰂 
  * 破坏性的数据
* 防御性设计不容易

#### 8.2 防错和容错

对于软件失效后果特别严重的场合，如飞机的飞行控制系统、空中交通管制系统等必须采用容错设计。

* N 版本编程法 
* 恢复块技术 
* 防卫式程序设计

#### 8.3 设计的评估和确认

* 数学确认
* 测量设计质量
* 比较设计
* 设计评审

#### 9. OO 设计主要工作是？

* 用例实现精化
* 体系结构设计 
* 构件设计 
* 用户界面设计 
* 数据持久化设计 
* 迭代精化

#### 10. 用例精化怎么做？

* 可利用 UML 的交互图（顺序图、协作图）用于用例实现方案的表示
* 三个步骤：
  * 􏰃取边界类、实体类和控制类
  * 构造交互图
  * 根据交互图精化类图

#### 10.1 软件体系结构

* 定义（IEEE）：一个系统的基础组织，包含各个构件、构件互相之间与环境的关系，还有指导其设计和演化的原则。
* 主流软件体系结构
  * 客户/服务器（CS）模式
  * 􏰁模型—视图—控制器（MVC）模式 􏰁 
  * 分层模式

#### 10.2 构件设计

构件设计将软件体系结构的结构元素变换为对软件构件的过程性描􏰀述。从基于类的模型、动态模型和静态模型等获得的信息作为构件设计的基础。

* 在相对较低的抽象层次上详细地说明所有算法
* 精化每个构件的接口
* 定义构件级数据结构
* 评审每个构件并修正所有已发现的错误

#### 10.3  设计模型精化的任务

* 以顶层架构图为基础，精化目标软件系统的体系结构
* 精化类之间的关系
* 精化类的属性和操作
* 针对具有明显状态转换特征的类，设计状态图
* 针对比较复杂的类方法，设计活动图

#### 11. 类的设计原则？

* **SRP 单一职责原则** 

  * 一个类应该有且只有一个改变的理由。即每一个类应该只专注于做一件事。
  * SRP 原则衡量的标准——内聚。写了高内聚的软件其实就是很好的应用了 SRP 原则。
  * 怎么判断一个职责是不是一个对象的呢？试着让这个对象自己来完成这个职责

* **OCP 开放关闭原则** 

  * 软件实体应该可以扩展，但不可以修改
  * 开放：从哲学上其实是要我们在设计和开发软件时􏰃提高抽象层次，不要总在具体对象层面上进行处理。
  * 关闭：设计好的类一定要对修改关闭

* **LSP 里氏替换原则** 

  子类型应该能代替掉其父类型，且代替后程序运行情况不会错乱。

* **DIP 依赖倒置原则** 

* **ISP 接口隔离原则**

  * 不应该强迫客户依赖于它们不要的方法。接口属于客户，不属于它所在的类层次结构。

#### 12. 详细解释 DIP

- 高层模块不应该依赖于低层模块，两者都应该依赖于抽象。
- 符合 DIP：低层模块实现了在高层模块中声明并被高层模块调用的接口
- 抽象不应该依赖于细节，细节应该依赖于抽象。
- 该启发式规则建议不应该依赖于具体类。也就是说，程序中所有的依赖关系都应该终止于抽象类或者接口
- 如果程序的依赖关系是倒置的，它就是面向对象的设计。 否则，它就是过程化的设计。

#### 13. 包设计原则？哪些是内聚？哪些是耦合？

* **包的内聚性**
  * **REP 重用发布等价原则**：重用的粒度就是发布的粒度，一个包中的软件要么都是可重用的，要么都是不可重用的
  * **CRP 共同重用原则** ：一个包中所有类应该是共同重用的。如果重用了包中的一个类，那么就重用包中的所有类
  * **CCP 共同封闭原则**：包中的所有类对于同一类性质的变化应该是共同封闭的。一个变化若对一个包产生影响，则将对包中的所有类产生影响，而对于其他的包不造成任何影响。
* **包的耦合性**
  * **ADP 无环依赖原则** ：在包的依赖图中，不允许存在环；若存在，利用 DIP 原则修改
  * **SDP 稳定依赖原则** ：朝着稳定的方向进行依赖
    * 设计不能是完全固定的。要使设计可维护，某种程度的易变性是必要的。我们通过遵循共同封闭原则（CCP）来达到这个目标。使用这个原则，可以创建对某些变化类型敏感的包。这些包被设计成可变的。
    * 对于任何包而言，如果期望它是可变的，就不应该让一个难以改变的包依赖于它
    * 可改变的包位于顶部并依赖于底部稳定的包
  * **SAP 稳定抽象原则** ：包的抽象程度应该和其稳定程度一致
    * 如果一个包是稳定的，那么它应该也要包含一些抽象类，这样就可以对它进行扩展。
    * 可扩展的稳定包是灵活的，并且不会过分限制设计。







### 十、软件实现

#### 1.1 准备工作

* 开发小组制定计划
* 开发小组确定编程、代码审查、内部测试等规范
* 开发小组构建编程与测试环境
* 确定是否安排相应的培训

#### 1.2 编程注意事项

* 尽可能采用成熟可靠的技术
* 单步跟踪调试
* 及时写编程日记
* 对代码进行配置管理
* 作息时间



* 内部测试
* 代码审查

#### 1.3 程序设计风格

* 源程序文档化
* 数据说明
* 语句结构
* 输入/输出方法