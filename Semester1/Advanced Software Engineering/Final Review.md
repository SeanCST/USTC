#### 题型

* 填空
* 选择 - 单选/不定项
* 辨析
* 简答/问答
* 分析



## 一、软件工程（概述）

#### 0. 什么是软件工程？

* 将工程化的思想/方法应用于软件开发的过程之中
* 软件工程 Fritz Bauer ：为了经济的获得可靠的，在实际机器上高效运行的软件，而建立和使用的好的工程原则。 
* 软件工程[IEEE93]：软件工程是
  * (1) 将系统的、规范的、可度量的方法应用于软件的开发、运行和维护的过程。即工程化方法应用于软件。
  * (2) 在(1)中所述方法的研究

#### 0.1   软件工程管理

* 目的：为了按照进度和预算完成软件开发计划 
* 内容：
  * 成本估算 
  * 进度安排 
  * 人员组织 
  * 质量保证

#### 0.2 软件危机

1968年第一次提出了“软件危机”(software crisis)这个名词并第一次提出了软件工程这个概念

软件危机包含两方面问题:

* 如何开发软件，以 满足不断增长、日趋复杂的需求
* 如何维护数量不断膨胀的软件产品

#### 0.2 现代软件工程最根本的就是人跟物的关系

是人和机器(工具、自动化)在不同层次的不断循环发展的关系，新的方法技术不断产生。例如:

* 面向对象的分析设计方法
* 软件复用
* 基于组件的软件开发
* 软件过程管理
* 能力成熟度模型的提出等

#### 0.3  计算机世界的软件

* 软件 = 程序 + 数据 + 文档
* 程序 = 算法 + 数据结构

#### 1. SE 和 CS 有什么区别？

* CS ：研究计算机相关的理论
* SE ：把计算机技术看作工具，用以解决问题

#### 2. 怎么认识质量？

* 超越的观点（Transcendental view）: 质量是可以认识而不能定义的
* 用户的观点（User view）: 质量是恰好达到目的
* 制造的观点（Manufacturing view）: 质量是与需求说明的一致
* 产品的观点（Product view）: 质量是与产品的内在特性相联系的
* 基于价值的观点（Value-based view）: 质量取决于顾客愿意支付的金额

#### 2.1 至少从三个方面考虑：

* 产品质量

| 产品运行 | •     正确性    •     可靠性    •     完整性    •     可用性    •     效率性 |
| -------- | ------------------------------------------------------------ |
| 产品修改 | •     可维护性   •     适应性   •     可测试性               |
| 产品变迁 | •     可移植性   •     可复用性   •     互用性               |

* 过程质量

* 商业环境中的质量

#### 3. 影响软件工程实践的七个关键因素（Wasserman 1996年提出）

* 交付时间的重要性
* 计算行业经济的变化趋势
* 功能强大的桌面运算
* 互联网络
* 面向对象的技术
* 图形用户界面
* 瀑布模型的不可预知性

#### 3.1  Wasserman 的软件工程规范8个基本概念

* Abstraction 抽象
* Analysis and design methods and notations 分析、设计方法和符号
* User interface prototyping 用户界面原形
* Software architecture 软件体系结构
* Software process 软件过程
* Reuse 复用
* Measurement 度量
* Tools and integrated environments 工具和集成环境 ：平台集成 数据集成 表示集成 控制集成 过程集成





## 二、软件过程

####1. 软件过程（软件生命周期）：是软件生命周期内为达到一定目标而必须实施的一系列相关过程的集合。 

三个时期：软件定义/软件开发/软件运行（维护）

* 可行性研究与计划
* 需求分析
* 概要设计（总体设计）
* 详细设计
* 实现（编码）
* 集成测试
* 确认测试
* 使用和维护

#### 1.1 什么是过程？

过程是指为达到给定目的而执行的一系列活动的有序集

#### 1.2 软件工程层次

* 四层：工具/方法/过程/质量焦点  
* 软件过程将各个技术层次结合在一起，并实施合理地、 及时地开发计算机软件

#### 2. 软件生命周期各阶段产品

* 可行性研究 ： 可行性报告
* 需求分析 
  * 软件需求规格说明书 SRS
  * 用户需求定义文档
* 概要设计 
  * 概要设计规格说明书
  * 数据库或数据结构设计说明书
  * 集成测试计划
* 详细设计
  * 详细设计规格说明书
  * 单元测试计划
* 实现 ：源程序代码
* 单元测试 ：单元测试报告
* 集成测试
  * 满足概要设计要求的程序
  * 组装（集成）测试报告
* 确认测试 ：可供用户使用的软件产品（文档，源程序） 

#### 2.1 软件过程各阶段内容

* **可行性研究**：

  任务：了解用户要求和现实环境。从技术、经济、市场等方面研究并论证开发该软件系统的可行性。

  * **技术可行性**：当前的软件开发方法和工具能否支持需求的实现;
  * **操作可行性**：用户能否在特定的环境下使用这个软件;
  * **经济可行性**：开发和使用、维护这个软件的成本能否被用户所接受。

* **需求分析**：

  任务：确定用户对软件系统的需求

  过程：需求分析人员必须与用户不断、反复地交流和商讨，使用户需求逐步准确、一致、完全。

  * **功能需求**：软件必须要完成的功能;
  * **性能需求**：软件的安全性、可靠性、可维护性、精度、错误处理、适应性、用户培训等;
  * **运行环境约束**：待开发的软件产品必须满足的环境要求

* **概要设计**：

  * 任务：根据 SRS 建立目标软件系统的总体结构、设计全局数据库和数据结构，规定设计约束，制定组装测试计划等等。
  * 原则：坚持功能模块内部高内聚，功能模块之间松耦合的；坚持与需求规格说明书的一致性

* **详细设计**：

  * 任务：细化概要设计所生成的各个模块，并详细描述程序模块的内部细节（算法，数据结构等），形成可编程的程序模块，制订单元测试计划

* **实现**：

  * 任务：调试、单元测试、系统集成，验证程序与详细设计文档的一致性
  * 方法：以详细设计规格说明书为依据、基于某种程序设计语言进行编码

* **单元测试**：

  * 任务：对模块进行测试
  * 途径：
    * 黑盒测试
    * 白盒测试

* **集成测试**：

  * 任务：组装测试应满足概要设计的要求。
  * 途径
    * 测试模块连接的正确性;
    * 测试系统或子系统的I/O;
    * 测试系统的功能和性能。

* **确认测试**：

  * 任务：根据软件需求规格说明书，测试软件系统是否满足用户的需求
  * 方法：用户参与，以软件需求规格说明书为依据进行确认测试
  * 工具：专用测试工具

* **使用和维护**：

  * 任务：软件工作环境不断变化，软件也必然跟着变化，软件必须不断进化以满足客户的需求变化，这是软件产品最根本的特性。软件维护占用软件开发60%以上的工作量。
  * 正确性维护 / 扩充性维护 / 适应性维护 / 软件产品的新版本

#### 3. 单元测试、集成测试、确认测试 各自的任务

* 单元测试 ：对模块进行测试
* 集成测试 ：应满足概要设计的要求
* 确认测试 ：根据软件需求规格说明书，测试软件系统是否满足用户的需求

#### 4.0 过程模型

* 软件过程模型是软件开发全过程、软件开发活动以及它们之间关系的结构框架
* 过程框架(process framework)：定义了若干小的框架活动，为完整的软件开发过程建立了基础。
* 软件通用过程框架：可适用于绝大多数的软件项目的过程框架：**沟通-策划-建模-构建-部署**
*  每个任务集合都由工作任务、工作产品、 质量保障点、项目里程碑构成

#### 4. 瀑布模型的优缺点 （1970 W.royce）

* 特点
  * 软件开发过程与软件生命周期是一致的
  * 相邻二阶段之间存在因果关系
  * 需对阶段性产品进行评审

* **优点**
  * **软件生命周期模型，使软件开发过程可以在分析、设计、编码、测试和维护的框架下进行**
  * **软件开发过程具有系统性、可控性，克服了软件开发的随意性**
* **缺点**
  * **项目开始阶段用户很难精确的提出产品需求，由于技术进步，用户对系统深入的理解，修改需求十分普遍。**
  * **项目开发晚期才能得到程序的运行版本，这时修改软件需求和开发中的错误代价很大。**
  * **采用线性模型组织项目开发经常发生开发小组员“堵塞状态”，特别是项目的开始和结束。**

#### 4.1 V 模型：软件开发过程与测试的对应

#### 4.2 快速原型模型

* 过程：
  * 用户/客户给出软件产品的一般需求
  * 开发小组和用户共同定义软件总体目标，标识已知需求
  * 对界面、功能、人机交互方式等，进行设计并建造原型
  * 强调“快速”，釆用基于构件的软件开发方法，尽量缩短软件开发周期，不宜釆用过多的新技术
  * 用户/客户对原型进行评估修改需求、更新设计、完善原型直至确定需求。

* 优点：
  * 原型模型支持软件需求开发，帮助用户和开发人员理解需求，是软件需求工程的关键。
  * 它产生的正式需求文挡，是软件开发的基础。
  * 如果开发的原型是可运行的，它的若干高质量的程序片段和开发工具可用于工作程序的开发。
  * 原型的开发和评审是系统分析员和用户/客户共同参予的迭代过程，每个迭代循环都是线性过程。

#### 4.3  RAD（快速应用开发）模型：侧重于短暂开发周期，多个团队可并行进行下面的工作

* 业务建模 —> 数据建模 —> 过程建模 —> 应用生成 —> 测试修正
* 缺点：
  * 对于大型软件项目，需要足够的人力资源以建立多个相对独立的 RAD 团队。
  * 如果开发者和客户没有短时间内没有为急速完成整个系统做好准备，RAD 项目将会失败
  * 如果系统难以模块化，建造原型所需构件就有问题
  * 如果高性能是一个指标，原型模型也可能不奏效。
  * 技术风险很高的情况下不宜采用该模型

#### 4.4 螺旋模型 （Boehm，1988）

* **螺旋模型 = 线性模型 + 迭代.原型 + 系统化**
* 螺旋模型适用于计算机软件整个生命周期
* 优点：
  * 符合人们认识现实世界和软件开发的客覌规律
  * 支持软件整个生命周期
  * 保持瀑布模型的系统性、阶段性
  * 利用原型评估降低开发风险
  * 开发者和用户共同参与软件开发，尽早发现软件中的错误
  * 不断推出和完善软件版本，有助于需求变化，获取用户需求，加强对需求的理解

#### 4.5 增量模型

* 增量：小而可用的软件
* 特点：在前面增量的基础上开发后面的增量，每个增量的开发可用瀑布或快速原型模型迭代的思路

#### 4.6 形式化开发方法

* 类似瀑布模型的软件开发方法，其开发过程是用**形式化数学转换**将系统描述转换成一个可执行程序
* 设计、实现和单元测试等开发过程由转换过程替代，在转换的过程中，每个步骤增加细节，直到形式化描述被转换变成一个可执行程序。
* 特点及优缺点：
  * 用严格的、数学的符号体系来规约、开发和验证基于计算机的系统。
  * 解决软件开发过程使用其它范型难以克服的二义性、不完整性和不一致性。
  * 可以产生无缺陷软件的承诺。
  * 费时、昂贵、难沟通，需要培训
  * **是建造重要的、安全的软件的开发者可以考虑开发范型。**

#### 4.7  构件集成模型（专用过程模型）

* 融合了螺旋模型的特征
* 基于构件库
* 支持软件开发的迭代方法
* 软件重用
* 基于构件的开发可以缩短大约70%的开发周期，降低84%的项目成本。
* **统一软件开发过程就是基于构件开发模型的代表。使用统一建模语言。**

#### 5.0 RUP（Rational Unified Process、Rational 统一过程）

* **用例驱动、以体系结构为核心、迭代及增量**
* 由 UML 方法和工具支持
* 目标：在可预见的日程和预算前提下，确保满足最终用户需求的高质量产品
* 适合于大范围项目和机构的方式捕捉了许多现代软件开发过程的最佳实践
* 各阶段里程碑：
  * 先启：生命周期目标里程碑
  * 精化：生命周期体系架构里程碑
  * 构建：初始可运行能力里程碑
  * 产品化：产品发布
* **迭代**：是一个基于确定计划和评估标准并且产生一个可执行发布版（内部的或外部的）的独特活动序列。

#### 5. RUP模型的四个阶段

* 先启 ：定义整个项目的范围
* 精化 ：制定项目计划、描述功能、建立体系架构框架和可执行的“体系结构基线”
* 构建 ：构造软件产品
* 产品化 ：将软件产品移交到最终用户手中

#### 6. RUP 模型和瀑布模型的区别

* RUP 每个阶段都包含软件生命周期的整个过程；瀑布模型每个阶段是独立的
* RUP 通过一次次迭代完成和完善软件开发；瀑布模型的软件开发是一次性的
* RUP 适用于大型复杂软件项目；瀑布模型适用小型简单软件项目

#### 7. 先启阶段主要工作

* 确定项目开发的目标和范围
* 定义主要的需求：用例以及主要的用例场景
* 根据一些主要的用例场景来构建一个基本架构
* 估算开发周期和成本估计潜在的风险
* 主要实践活动 —— 用例建模

#### 7.1 精化阶段主要工作

* 精化阶段不是一个需求或设计阶段，而是一个迭代实现核心架构并降低高风险的阶段
* 在细化前不需要定义大多数需求，10% 的详细用例书写出来即可
* 先处理具有风险的元素，开始实际产品代码的编写，产生可执行架构
* 除了极少数理解良好的问题外需要多次迭代

#### 8. 构建阶段主要工作

* 尽快完成软件产品的开发
* 迭代实现遗留下来的风险较低和比较容易的元素，准备部署
* 在保证开发进度的同时达到足够的软件质量
* 获得一些有用的版本（alpha，beta 等）

#### 8.1 转化阶段

* 获得涉众的认同：产品部署已经完成并且满足预定的质量标准
* 尽快达到最终稳定的产品基线

#### 8.2 统一过程的模型

* 用例模型：用例与用户之间关系（交互时）
* 分析模型：系统的行为初步分配给一组对象
* 设计模型：系统静态结构定义为子系统、类、接口，并定义由子系统、类和接口之间的协作所实现的用例
* 实现模型：构件（表现为源代码）和类到构件的映射
* 实施模型：计算机的物理节点和构件到这些节点的映射
* 测试模型：用于验证的测试用例

#### 8.3 过程建模工具和技术

* Choose Language or Notation：选择语言或符号
* Static model：显示了输入转化为输出的过程
* Dynamic model：能够执行过程，用户可以看到中间过程和最后结果是如何转化的



## 三、 软件计划与管理

#### 0.0 项目计划与管理概述

* 目的：为了使软件项目能够在预定成本􏰀、进度、质量的前提下顺利完成，必须对软件工程项目进行计划、组织、监控和管理
* 项目的特征：唯一性 / 一次性 / 整体性 / 多目标性 / 寿命周期阶段性
* 管理是所有人类组织都有的一种活动，这种活动由五要素组成：**计划、组织、指挥、协调、控制**，管理就是实施这五要素
* 项目管理：所谓项目管理，就是项目的管理者，在有限的**资源约束**下，运用**系统的观点、方法和理论**，对项目涉及的全部工作进行有效地管理
* 软件项目管理：
  * 是为了使软件项目能够按照预定的成􏰀本、进度、质量顺利完成，而对成本􏰀、人员、进度、 质量、风险等进行分析和管理的活动。
  * 对象：软件工程项目，它所涉及的范围覆盖了整个软件工程过程。
  * 目的：
    * 让软件项目尤其是大型项目的整个软件生命周期（从分析、设计、编码到测试、维护全过程）都能在管理者的控制之下，以预定成本􏰀按期、按质的完成软件交付用户使用。
    * 从已有的成功或失败的案例中总结出能够指导今后开发的通用原则，方法，同时避免前人的失误。
  * 范围：**人员 / 产品 / 过程 / 项目**

#### 1.0 项目（过程）跟踪

* (Activity) 活动：项目的一部分，发生在一段时间内
* (Milestone) 里程碑：一个活动的完成，某一特定时刻
* (Precursor) 前驱：在活动开始之前必须发生的一个或一组事件
* (Duration) 持续时间：完成一个活动需要的时间长度
* (Due date) 截止日期: 活动必须完成的日期

#### 1. 拿到项目先做什么？ 进行项目分解

#### 1.1 项目分解

* 含义：项目组在项目实施期间要完成的工作或要开展的活动的一种层次性、树状的项目活动描述。组织并定义了整个项目范围，建立和确认项目范围，以便达成共识。工作元素经常被收集在 WBS 词典中，一般包括工作描述和其他项目信息
* **目的：明确项目所包含的各项工作；项目分解的结果就是 WBS**
* 意义：WBS 图是实施项目、创造最终产品或服务所必须进行的全部活动的一张清单，也是进度计划、人员分配、预算计划的基础
* 内容：项目分解就是先把复杂的项目逐步分解成一层一层的要素（工作），直到具体明确为止

#### 2. WBS 是什么？

Work Breakdown Structure 任务分解结构

#### 3. 简述 WBS 的叶子结点

* WBS 主要是将一个项目分解成易于管理的几个部分或几个细目，以便确保找出完成项目工作范围所需的**所有工作要素**，它是一种在项目全范围内分解和定义各层次工作包的方法
* **WBS 结构层次越往下层则项目组成部分的定义越详细，WBS 最后构成一份层次清晰、可以具体作为组织项目实施的工作依据**

* **WBS 通常是一种面向“成果”的“树”，其最底层（叶子结点）是细化后的“可交付成果”，该树组织确定了项目的整个范围。但 WBS 的形式并不限于“树”状，还有多种形式。**

#### 3.1 WBS 的用途？

* 确定工作范围
* 配备人员
* 编制资源计划
* 监视进程
* 明确阶段里程碑
* 内容的验证

#### 4.1 WBS 分解注意事项？ 

* WBS 分解的规模和数量因项目而异
* 收集与项目相关的所有信息
* 参看一下类似的项目的 WBS，与相关人员讨论
* 可以参照相关模板
* **最低层是可控的和可管理的，但是避免不必要的过细，最好不要超过7 层**
* **软件项目推荐分解到40小时的任务**
* **工作包（处于最底层）必须有一个提交物**
* 定义任务完成的标准
* 必须有利于责任分配
* 可以准备WBS的字典
* 进行评审

#### 5. WBS 的两种分解方法

* **基于可交付成果的划分**
  * 上层一般为可交付成果为导向
  * 下层一般为可交付成果的工作内容
* **基于工作过程的划分**
  * 上层按照工作的流程分解
  * 下层按照工作的内容划分

#### 5.1 WBS 表现形式

* 图形显示
* 锯齿列表

#### 5.2 WBS 字典

由于项目，特别是对于那些较大的项目来说都有许多工作块，而对于这些最底层的工作块，要对它们有全面、详细和明确的文字说明。因此，常常把这些所有的工作块文字说明汇集在一起，编成一个项目的工作分解结构词典(WBS dictionary)，以便需要时查阅。

#### 5.4 WBS 应用

* WBS — 工作分解结构
* OBS — 组织分解结构 （人员）
* CBS — 成􏰀本分解结构 
* RBS — 风险分解结构
* WBS — OBS责任矩阵
* WBS — CBS帐户(科目) 矩阵
* WBS — RBS风险矩阵

#### 6.1 项目人员（五类）

* 项目管理人员
* 高级管理人员
* 开发人员
* 客户
* 最终用户

#### 6. 如何选择人员？（以下特性可能影响个人工作的生产力）

* 开展工作的能力
* 工作兴趣
* 经验
  * 类似应用
  * 类似工具或语言
  * 类似技术
  * 类似开发环境
* 培训
* 与其他人交流的能力
* 共同承担责任的能力
* 管理技能

#### 6.1 项目组织

* 如何选择适当的结构？
  * 小组人员的背景和工作方式 
  * 小组的工作数目
  * 顾客和开发人员的管理方式

*  三种常见的程序设计小组的组织形式

  * 核心程序员制小组（高结构化） 
  * 民主制小组（松散结构） 
  * 层次式小组（高结构化和松散结构两者之间）

* 组织结构的比较

  | 高度结构化 |  松散的结构  |
  | :--------: | :----------: |
  |  高确定性  |    不确定    |
  |    重复    | 新技术或工艺 |
  |   大项目   |    小项目    |

#### 7.0 规模（工作量）估算

* 估算的步骤
  * 在技术允许的条件下，应从最详细的工作分解结构开始 
  * 精确定义度量的标准
  * 估计底层每一模块的规模，汇总已得到总体的估算
  * 适当考虑偶然因素的影响
* LOC 估算与 FP 估算
  * LOC：代码行可以分为无注释的源代码行 (NCLOC) 和注释的源代码行 (CLOC)，源代码的总行数 LOC 即为NCLOC 与 CLOC 之和。利用 LOC 为指标进行估算。
    * 代码行数：LOC 或 KLOC
    * **生产率：Pl = L / E**，其中 L 是软件项目代码行数，E 是软件项目工作量(人月 PM)，Pl是软件项目生产率 (LOC / PM)
    * **代码出错率：EQRl = Ne / L**，其中 Ne 是软件项目的代码错误数，EQRl 是每千行代码的错误数
    * **每行代码平均成本：Cl = S / L**，其中 S 是软件项目总开销(元/美元)，Cl 是软件项目每行代码的平均成􏰀本
    * **文档与代码比：Dl = Pd / L**，其中Pd是软件项目文档页数，Dl是每千行代码的平均文档数
  * FP：功能点，根据事务信息处理程序的基􏰀本功能定义的，利用 FP 为指标进行估算。
    * 功能点分析法是可在需求分析阶段基于系统功能的一种规模估算方法，它的运用可以贯穿于整个软件生命周期。是基于应用软件的外部、内部特性以及软件性能的一种间接的规模测量。
    * 功能点分析的一个主要的目标就是从**用户的角度**定义系统的能力

#### 7. LOC、FP 的优缺点

* LOC 
  * 优点：用软件代码行数估算软件规模简单易行
  * LOC 缺点： 
    * 代码行数的估算依赖于程序设计语言的功能和表达能力
    * 采用代码行估算方法会对设计精巧的软件项目产生不利的影响
    * 在软件项目开发前或开发初期估算它的代码行数十分困难
    * 代码行估算只适用于过程式程序设计语言，对非过程式的程序设计语言不太适用
* FP
  *  优点：
    * 与程序设计语言无关，它不仅适用于过程式语言，也适用于非过程式的语言;
    * 软件项目开发初期就能基本上确定系统的输入、输出等参数，功能点度量能用于软件项目的开发初期。
  * FP 缺点：
    * 它涉及到的主观因素比较多，如各种权函数的取值
    * 信息领域中的某些数据有时不容易采集
    * FP的值没有直观的物理意义。

#### 7.1 比较

* 代码行度量依赖于程序设计语言，而功能点度量不依赖于程序设计语言。
* FP法需要某种“人的技巧”，因为计算是基于主观的而非客观的数据;
* 两者可以结合使用。例如：在实践应用中，在全生命周期采用 FP 的同时，在项目内部局部结合使用 LOC 作为补充手段。

#### 8. 功能点分类 

* 数据类型 ：ILF（内部逻辑文件）、EIF（外部接口文件）
* 人机交互类型 ：EI（外部输入）、EO（外部输出）、EQ（外部查询）：都是逻辑处理
  * EI：外部输入是指一个基本处理，它处理的是来自本应用边界之外的一组数据或者控制信息。外部输入的基本目的是为了维护一个内部逻辑文件（ILF）或者改变系统行为。
  * EO：外部输出是指一个向应用边界之外发送数据或者控制信息的基本处理。
  * EQ：外部查询是指一个向应用边界之外发送数据或者控制信息的基本处理。

#### 9. EO 和 EQ 的区别

* EO：基本目的是为了向用户展示一组经过了除了提取之外的其他逻辑处理的数据或者控制信息。其他处理包括至少一个数学演算或者对衍生数据的生成。可能包括对 ILF 的维护或者对系统行为的改变。
* EQ：基本目的是为了向用户展示提取的数据或者控制信息。逻辑处理里不包含数学公式或者计算以及对衍生数据的生成。不维护 ILF，也不会引起系统行为的改变

#### 10.0 文件

* ILF 内部逻辑文件
  * 指一组以用户角度识别的，在应用程序边界内且被维护的逻辑相关数据或控制信息。
  * ILF 主要的目的是通过应用程序的一个或多个基本处理过程来维护数据。
* EIF 外部接口文件
  * 指一组在应用程序边界内被查询，但它是在其他应用程序中被维护的，以用户角度来识别的，逻辑上相关的数据。
  * 一个应用程序中的 EIF 必然是其他应用程序中的 ILF。
  * 主要目的是为边界内的应用程序提供一个或多个通过基础操作过程来引用的一组数据或信息。
* ILF 和 EIF 的复杂性取决于 DET 和 RET 的数量

* FTR（应用文件类型）：
  * 一个由交易功能所维护的 ILF
  * 一个被交易功能所读取的 EIF

#### 10. DET（Data element type） 和 RET（Record element type）的概念

* DET 是一个以用户角度识别的，非重复的有业务逻辑意义的**字段**
* RET 是指一个 EIF / ILF 中用户可以识别的 **DET 的集合**。
* 如果把 DET 简单理解为字段的话，那么 RET 就可以简单理解为数据库中的表

#### 11. 功能点计算的大致过程

 ![FP](/Users/Sean/Desktop/复习 md/USTC/Semester1/images/FP.png)

![image](https://github.com/SeanCST/USTC/blob/master/Semester1/images/FP.png)

#### 11.1 FP 计算：FP = CT * [0.65 + 0.01 * ∑Fi ]

* CT 为􏰁未调整的功能点  
* Fi 是复杂性调节值，Fi 取值 0,1,...,5，当 Fi = 0 时，表示 Fi 不起作用， Fi = 5 时，表示 Fi 作用最大

#### 11.2 FP 相关计算

*  生产率：Pf = FP / E，Pf 表示每人月完成的功能点数，E 是软件项目工作量(人月 PM)
*  平均成􏰀本：Ci = S / FP，Ci表示每功能点的平均成本
*  文档与功能点比：Di = Pd / FP，Di 表示每个功能点平均具有的文档页数
*  代码出错率：EORi = Ne / FP，EORi 表示每个功能点的平均错误个数

#### 11.3 成本估算

* 估算类型
  * 专家判定
  * 算法模型
  * 机器学习

#### 11.4 可靠性估计 ：与软件可靠性密切相关的程序中残留错误数的估算和平均故障间隔时间的估算

* 错误植入法：假设程序中测试前残留的错误数为 N，然后人为地在程序中植入 Ns 个错误，这些植入的错误对测试人员来说是未􏰁知的。经过一段时间的测试，如果发现的错误数为 n，其中植入的错误数为 ns，则原程序中残留的错误估算值 N' 可用下式计算：N′ = (n * Ns) / ns
* 分别测试法：
  * Er = 程序中原有的残留错误数
  * E1 = 第一组测试员发现的错误数 
  * E2 = 第二组测试员发现的错误数 
  * E0 = 两组测试员同时发现的错误
  * 则程序中残留错误的估计值可用下列计算：Er = (E1 * E2) / E0
* 软件平均故障间隔时间估算
  * 统计程序运行 H 小时期间出现的故障次数 r 来估算软件故障率 λ
  * 估算公式如下：λ = r / H
  * 软件的平均故障时间 MTTF 可用下式估算：MTTF = 1 / λ = H /r 
  * 根据软件项目组对以往项目的故障修复时间的统计，可得到平均故障修复时间 MTTR，则软件平均故障间隔时间可用下式估算：MTBF = MTTF + MTTR = H / r + MTTR

#### 11.4 进度估算与管理

* 目标：确保软件项目在规定的时间内按期完成
* 项目进度管理任务
  * 定义所有的项目任务以及它们之间的依赖关系
  * 制订项目的进度安排
  * 规划每个任务所需的工作量和持续时间
  * 在项目开发过程中不断跟踪项目的执行情况，发现那些􏰁未按计划进度完成的任务对整个项目工期的影响，并及时进行调整
* 进度管理指导原则：
  * 划分
  * 相互依赖性
  * 时间分配
  * 工作量确认
  * 定义责任
  * 定义结果
  * 定义里程碑
* 进度管理过程：
  * 活动定义
  * 活动排序
  * 活动历时估计
  * 指定进度计划
  * 进度控制
* 进度安排图表
  * 网络图：展示项目中的各个活动以及活动之间的逻辑关系； 网络图是活动排序的一个输出；网络图可以表达活动的经历时间。常用网络图有 PDM、ADM。
  *  PDM (Precedence diagram)
    * 构成 PDM 网络图的基􏰀本特点是节点
    * 节点表示活动
    * 用箭线表示各活动之间的逻辑关系
    * 可以方便的表示活动之间的各种逻辑关系
    * 每项活动有唯一的活动号，每项活动都注明了预计工期
    *  PDM 包括四种依存关系或先后关系：完成对开始 / 完成对完成 / 开始对开始 / 开始对完成
  * 甘特图
    * 也称时间表（Timeline chart），用来建立项目进度表
    * 在甘特图中，每项任务的**完成以必须交付的文档和通过评审为标准**
    * 因此在甘特图中，文档编制与评审是软件开发进度的里程碑
  * 里程碑图
    * 里程碑显示项目进展中的重大工作完成 
    * 里程碑不同于活动
      * 活动是需要消耗资源的
      * 里程碑仅仅表示事件的标记

#### 12.0 编制进度计划

* 编制项目进度计划
  * 确定项目的所有活动及其开始和结束时间
  * 监控项目实施的基础，它是项目管理的基准
  * 计划是三维的，考虑时间、费用和资源 
* 编制项目进度计划步骤
  * 进度编制 
  * 资源调整 
  * 成􏰀本预算 
  * 计划优化调整 
  * 形成基线计划

#### 12. 制定进度计划的常见技术是？

* 关键路径 （CPM）：根据指定的网络顺序逻辑关系和单一的历时估算，计算每个活动的单一的、确定的最早和最迟开始和完成日期，计算网络图中完成时间最长的路径和浮动时间。
  * 正推法：按照时间顺序计算最早开始时间和最早完成时间的方法
    * 首先建立项目的开始时间
    * 项目的开始时间是网络图中第一个活动的最早开始时间
    * 从左到右，从上到下进行任务编排
    * 当一个任务有多个前置时，选择其中最大的最早完成日期作为其后置任务的最早开始日期
    * ES（最早开始时间）、EF（最早完成时间）、LS（最晚开始时间）、LF（最晚结束时间）
  * 逆推法：按照逆时间顺序计算最晚开始时间和最晚结束时间的方法
    * 首先建立项目的结束时间
    * 项目的结束时间是网络图中最后一个活动的最晚结束时间
    * 从右到左，从下到上进行计算
    * 当一个前置任务有多个后置任务时，选择其中最小最晚开始日期作为其前置任务的最晚完成日期
* 计划评审技术（PERT）：
  * 利用经加权平均的所需时间估算，计算各项活动所需时间。PERT 同 CPM 的主要差别在于 PERT 使用**期望值来估算时间**，而不使用 CPM 所用的最大可能估计。
  *  PERT 的计算特点：在 PERT 中，假设各项工作的持续时间服从 β 分布，近似地用三时估计法估算出三个时间值，即最短、最长和最可能持续时间，再加权平均算出一个期望值作为工作的持续时间
  * 为了进行时间的偏差分析(即分布的离散程度)，可用方差估算
* 图形评审技术（GERT）：
  * 可对网络逻辑和活动所需**时间估算进行概率处理**（即，某些活动可能根􏰀本不进行，某些活动可能只部分进行，而其它活动则可能多次进行)。
  * 具体技术的选择考虑如下因素：
    * 项目的规模大小
    * 项目的复杂程度
    * 项目的紧急性
    * 对项目细节掌握的程度
    * 总进度是否由一、两项关键事项所决定
    * 有无相应的技术力量和设备。

#### 13. 什么是风险？

在给定情况下和特定时间内，那些可能发生的结果与预期结果之间的差异，差异越大，风险越大

#### 14. 什么是风险后果、概率、控制？

* 风险后果 ：与该事件有关的损失
* 风险概率 ：事件发生的可能性
* 风险控制 ：我们能改变结果的程度

#### 15. 什么是风险成本？

***风险成本 = 风险概率 × 风险后果***

#### 16. 风险管理的四个方面

风险管理 ：识别评估风险，建立、选择、管理和解决风险的可选方案和组织方法

* **风险标识** ：潜在的风险列表
  * 风险的类别：
    * 项目风险
    * 技术风险
    * 商业风险
  * 影响软件风险的因素：
    * 性能风险
    * 成本风险
    * 支持风险
    * 进度风险
* **风险预测** ：评价每种风险发生的可能性或概率以及当该风险发生时所导致的后果 
  * 建立一个尺度，以反映风险发生的可能性
  * 描述风险的后果
  * 估算风险对项目及产品的影响
  * 标注风险预测的整体精确度以免产生误解
  * 建立风险表：
    * 第 1 列列出所有的风险
    * 第 2 至 4 列列出每个风险的种类（项目风险、技术风险、商业风险等）、发生的概率以及所产生的影响
    * 综合考虑风险发生的概率和风险所产生的影响，对风险表排序
* **风险评估** ：进一步审查风险预测阶段对各种风险预测的精确度，并对每个风险因素定义一个风险参考水准。当性能下降、成本超支、支持困难或进度延迟超过相应的水准时会导致项目被迫终止。（风险计划和应急计划）

  * 风险评估活动通常采用下列形式的三元组： [ri, li, xi]
  * ri ：风险

  * li ：风险发生的概率
  * xi ：风险产生的影响
* **风险管理与监控** ：建立处理风险的策略
  * 风险避免：对付风险的最好办法是主动地避免风险，即在风险发生前，分析引起风险的原因，然后采取措施，以避免风险的发生
  * 风险监控：监控可以提供风险指示（是否正在变高或变低）的因素
  * 风险管理及监控计划 RMMP：对于每个风险，特别对那些高概率高影响的风险应制定 RMMP，RMMP 的实施会导致额外的项目开销

#### 17.0 软件质量管理

* 高质量的软件应该具备以下条件：
  * 满足软件需求定义的功能和性能
  * 文档符合事先确定的软件开发标准
  * 软件的特点和属性遵循软件工程的目标和原则
* 还应该考虑在预算和进度范围内交付，因此在项目进行过程中要对偏差进行控制

#### 17. QC（质量控制） 具体是什么？包含什么？

* 为保证每一件工作产品都满足需求而应用于整个开发周期中的一系列**审查、评审和测试**
  * 质量控制在创建工作产品的过程中**包含**一个**反馈循环**，通过对质量的反馈，使得能够在得到的工作产品不	能满足其规约时调整开发过程 
  * 所有工作产品都应该具有定义好的和**可度量的规约**，这样就可以将每个过程的产品与这一规约进行比较 

* 方法 ：
  * 采用技术手段保证软件质量
  * 组织技术评审
  * 加强软件测试
  * 推行软件工程标准
  * 对软件的修改、变更进行严格控制
  * 对软件质量进行度量

#### 18. QA（质量保证）具体是什么？

* 建立一套有计划，有系统的方法，来向管理层保证拟定出的标准、步骤、实践和方法能够正确地被所有项目所采用。**（管理者的眼睛）**

* 目的：**使软件过程对于管理人员来说是可见的**。它通过对软件产品和活动进行评审和审计来验证软件是合乎标准的。软件质量保证组在项目开始时就一起参与建立计划、标准和过程。这些将使软件项目满足机构方针的要求。

* 目标：
  * 软件质量保证工作是有计划进行的
  * 客观地验证软件项目产品和工作是否遵循恰当的标准、步骤和需求 
  * 将软件质量保证工作及结果通知给相关组别和个人
  * 高级管理层接触到在项目内部不能解决的问题

#### 18.1 软件质量评价特性

* 常见的 6 个方面：
  * 正确性
  * 可靠性
  * 易用性
  * 效率
  * 可维护性
  * 可移植性
* 其他方面的特性：
  * 健壮性
  * 完整性（安全性）
  * 可测试性
  * 可再用性
  * 可互连性

#### 18.2 软件评审

* 软件评审是软件质量保证的重要手段
* 通常在软件工程过程的每个活动（如需求分析、设计、编码）的后期进行正式的软件评审
* 两种主要评审活动：项目管理评审和技术评审
  * 项目管理评审的任务是针对适用的项目计划、进度安排、标准和指南进行项目状态的评价
* 软件评审的方法：正式评审 / 非正式评审

#### 19. 什么是软件配置？

由在软件工程过程中产生的所有**信息项**构成的，它可以看作该软件的具体形态（软件配置项）在某一时刻的**瞬间影像**

#### 20. 什么是软件配置管理？为什么要进行配置管理？

协调软件开发**使得混乱减到最小的技术**叫做软件配置管理，它是一种标识、组织和控制修改的技术，目的是使错误达到最小并最有效地提高生产效率。贯穿整个软件生命周期与软件工程过程。

#### 20.1 软件配置管理

* 目标：标识变更 • 控制变更 • 确保变更 • 报告变更
* 基本概念：
  * 软件配置项 (Software Configuration item，SCI) : 为配置管理设计的软件的集合，它在配置管理过程中作为单个实体对待。配置项主要有两大类：
    * 属于产品组成部分的工作成果，例如源代码、需求文档、设计文档、测试用例等等
    * 在管理过程中产生的文档例如各种计划、监控报告等等，这些文档虽然不是产品的组成部分，但是值得保存。
  * 软件配置 (Software configuration) : 软件产品在不同时期的组合。该组合随开发工作的进展而不断变化。
  * 配置管理 (Configuration management) : 应用技术的和管理的指导和监控方法以标识和说明配置项的功能和物理特征，控制这些特征的变更，记录和报告变更处理和实现状态并验证与规定的需求的遵循性。
  * 版本􏰀 (Version) : 与计算机软件配置项的完全编篡或重编篡相关的计算机软件配置项的初始发布或再发布
  * 发布 (Release) : 一项配置管理行为，它说明某配置项的一个特定版􏰀已准备好用于特定的目的（例如发布测试产品)
  * 基线 (baseline) : 已经过正式审核与同意，可用作下一步开发的基础，并且只有通过正式的修改管理过程方能加以修改的规格说明或产品。
  * 变更控制 (change control) : 是指提议作一项变更并对其进行估计、同意或拒绝、调度和跟踪的过程。
  * 配置状态记录 (configuration status accounting) : 一种配置管理的元素，它为有效地管理某一配置所需的信息组成。此信息包括列出经批准的配置标识表、建议变更的配置状态和经批准变更的实现状态。

#### 21. 什么是配置审计？

配置审计（Configuration audit）是指对所要求的全部配置项均已产生出来，**当前的配置与规定的需求相符所作的证明**。技术文件说明书完全而准确地描述了各个配置项目，并且曾经提出的所有变更请求均已得到解决的过程。

#### 21.1 配置项管理的关键活动

* 配置项识别：所有配置项都应按照相关规定统一编号，按照相应的模板生成，在引入软件配置管理工具进行管理后，这些配置项都应以一定的目录结构保存在配置库中。
* 配置空间管理：在引入了软件配置管理工具之后，所有开发人员都会被要求把工作成果存放到由软件配置管理工具所管理的配置库中去。所以要对工作进行空间配置。
* 版本控制：对系统不同版􏰀本进行标识和跟踪的过程，演化图：描述对象的变更历史
* 变更控制：变更控制结合人的规程和自动化工具以提供一个管理变更的机制
* 配置审计
  * 审计：通过调查研究确定已制定的过程、指令、规格说明、基线及其他特殊要求是否恰当和被遵守、以及实现是否有效
  * 通过正式技术评审或软件配置审计来保证变更的有效性
* 配置状态报告 (CSR) 主要内容：
  * 配置库结构和相关说明;
  * 开发起始基线的构成;
  * 当前基线位置及状态;
  * 各基线配置项集成分支的情况; 
  * 各私有开发分支类型的分布情况; 
  * 关键元素的版􏰀演进记录;
  * 其它应予报告的事项。





## 四、敏捷软件开发

#### 1. 敏捷的出发点

* 以人为本
* 尽快的交付客户满意的增量

#### 2. 敏捷的四条宣言

* **个体和交互** 胜过 过程和工具
* **可以工作的软件** 胜过 面面俱到的文档
* **客户合作** 胜过 合同谈判
* **响应变化** 胜过 遵循计划
* *虽然右项也有价值，但我们认为左项具有更大的价值*

#### 2.1 敏捷实践原则

* 我们最优先要做的是通过**尽早的、持续的交付有价值的软件**来使客户满意。 
* 即使到了开发的后期，也**欢迎改变需求**。敏捷过程利用变化来为客户创造竞争优势。
* 经常性的交付**可以工作的软件**，交付的间隔可以从几个星期到几个月，交付的时间间隔越短越好。
* 在整个项目开发期间，业务人员和开发人员必须**天天都在一起工作**。
* 围绕**被激励起来的个体**来构建项目。给他们􏰀提供所需的环境和支持，并且信任他们能够完成工作。
* 在团队内部，最具有效果并且富有效率的传递信息的方法，就是**面对面的交谈**。
* **工作的软件**是首要的进度度量标准。 
* 敏捷过程􏰀提倡**可持续的开发进度**。责任人、开发者和用户应保持一个长期恒定的开发速度。
* 不断关注**优秀的技能和好的设计**会增强敏捷能力。 
* 简单 — 使**未完成的工作**最大化的艺术 — 是根本的。 
* 最好的构架、需求和设计出自于**自组织的团队**。
* 每隔一定时间，团队会在如何才能更有效的工作方面进行反省，然后相应地对自己的行为进行调整。

#### 3. XP 模型和 Scrum 模型的异同点

* **Scrum 和 XP team 都在迭代的方式下工作，但 Scrum 的周期一般是从两周到一个月  /  XP 的周期是一或两周。**
* Scrum team 在一个 sprint 中是不接受任何任务变更的。一旦 sprint planning meeting 提交了任务，直到 sprint 结束，都不会接受任何改变 **/** 而 XP 的团队在一个迭代中，如果新的 feature 跟原来的 feature 规模和大小差不太多，在原来的 feature 还没有开始进行的前提下，可以用新的 feature 更换原来的 feature。
* XP 团队会严格按照任务的优先级来工作。所有的任务都被客户划分了优先级，团队都被要求在该优先级下工作。相比之下，Scrum 团队中的 PO 也会划分 backlog 中的优先级，但 scrum 团队的人员会自己决定他们以何种顺序来完成所有的任务。当然，通常来说，还没见过哪个 scrum 团队不选择优先做优先级最高的条目。当然有时候，scrum 团队也会选择先做优先级稍微低一些的条目，比如有些任务并非在 sprint 刚一开始就实施的，尽管它的优先级很高。或者适合做某项任务的人，正在做**其他**的工作，这个时候，优先级也会得到调整。
* **Scrum 并没有定义任何工程实践的方法，它只是提供了一个实践的框架给你。但XP（极限编程）却会给你这样的一些东西。比如测试驱动开发， 自动化测试，结对编程，简单设计，重构等等。**
* **scrumMaster 负责监督整个 Scrum 进程**
* XP：素材划分为任务，迭代进行到一半时应完成本次迭代中所安排的半数素材，每次迭代结束时会给客户演示当前可运行的程序，客户以新的用户素材的方式提供反馈 **/** Scrum： 任务为backlog ，sprint backlog 是一个 sprint 周期内需要完成的任务

#### 3.1 XP 极限编程实践

* 完整团队
* 计划游戏
  * 通过一次次迭代和发布，项目进入了一种可以预测的、舒适的开发节奏。
  * 开发人员看到的是他们自己估算、自己度量的开发速度控制的合理计划。选择舒适的任务并保持高的工作质量。
  * 管理人员从每次迭代中获取数据，使用这些数据来控制和管理项目。
* 客户测试
* 简单设计
* 结对编程
* 测试驱动开发
  * 程序中的每一项功能都有测试来验证它的**操作的正确性**。
  * 迫使我们使用不同的**观察点**，可以设计出便于调用的软件。
  * 迫使我们**解除软件中的耦合**。
  * 测试可以作为一种无价的文档形式，这份文档是可编译、可运行的。它保持最新，不会撒谎。
* 改进设计
* 持续集成
* 集体代码所有权
* 系统隐喻
* 可持续的速度
* 编码标准

#### 3.2 Scrum 的一些基本概念

* backlog：可预知的所有任务
* sprint：一次迭代开发的时间周期
* sprint backlog
* scrumMaster：监督进程、修订计划
* time-box：一个用于开会的时间段
* sprint planning time：在启动每个 sprint 前召开
* Daily scrum meeting
* Sprint review meeting
* Sprint Retrospective meeting



## 五、需求工程

#### 1. 需求工程的出发点

* 获取用户最真实的需求
* 用规格化的语言进行描述

#### 2. 需求分析的四个阶段

* 导出需求 
  * 需求协同收集——准备列表：对象列表、服务列表、约束列表、性能列表
* 分析建模
* 规格说明
* 需求确认和校验

#### 3. 什么是需求校验与需求确认？主要工作是什么？

* **需求确认** ：目的是用来检查获得的**需求定义**是否准确的反应了用户的实际需求。
* **需求校验** ：目的是用来检查**需求规格说明文档**和需求定义文档是否一致。

#### 4. 为什么要进行需求分析建模？
* 建立分析模型。从不同的角度、不同的抽象级别精确地说明对问题的理解、对目标软件的需求。
* 模型可帮助用户和分析人员发现、排除用户需求不 一致，不合理的部分，挖掘潜在的用户需求。 
* 模型是分析人员根据初步导出的需求而创建的软件系统结构，包括相关的信息流、处理功能、用户界面、行为及设计约束。
* 模型是形成需求规格说明、进行软件设计的基础。




## 六、结构化分析过程

#### 1. 过程论观点——过程论是怎么看待程序世界的？

*  1> 数据和逻辑是分离的、独立的，各自形成程序世界 的一个方面。所谓世界的演变，是在逻辑作用下，数据做改变的一个过程。 
* 2 > 过程有明确的开始、结束、输入、输出，每个步骤有着严格的因果关系。 
* 3 > 过程是相对稳定的、明确的和预定义的，小过程组合成大过程，大过程还可以组合成更大的过程。 
* **结论 ：程序世界本质是过程，数据作为过程处理对象，逻辑作为过程的形式定义，世界就是各个过程不断进行的总体。** 

#### 2. 什么是结构化分析方法？

* 结构化分析方法是一种**建模技术** 
* 基于计算机的系统是**数据流和一系列的转换**构成的 
* 在模型的**核心是数据词典**，它描述了所有的在目标系统中使用的和生成的数据对象。围绕着这个核心的有三种图：ERD、DFD、STD 
  * 数据字典是模型的核心，包含软件使用和产生所有数据的描述。 
  * DFD 数据流图：用于**功能建模**，描述系统的输入数据流如何经过一系列的加工变换逐步变换成系统的输出数据流。 
  * ERD 实体关系图：用于**数据建模**，描述数据字典中数据之间的关系。 
  * STD 状态迁移图：用于**行为建模**，描述系统接收哪些外部事件，以及在外部事件的作用下的状态迁移情况。 

#### 3. 结构化分析模型包含什么？

* 数据建模和对象描述
* 功能建模和数据流图 DFD
* 基本加工逻辑说明 ERD
* 行为建模 STD
* 数据词典